{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction \u00e0 Python en Sciences de la nature","text":"<p>Le langage Python</p> <p></p> <p>Le langage Python est utilis\u00e9 depuis pr\u00e8s de 30 ans principalement dans le traitement des donn\u00e9es. La version utilis\u00e9e pour cette formation est Python 3.12.</p> <p>Visiter le cite de Python Software Foundation.</p>"},{"location":"#structure-de-la-formation","title":"Structure de la formation","text":"<p>La formation se veut un r\u00e9sum\u00e9 des principaux \u00e9l\u00e9ments de la comp\u00e9tence 0F01 : D\u00e9velopper des programmes informatiques en vue d\u2019automatiser la r\u00e9solution de probl\u00e8mes dans un contexte scientifique. du programme 200.B1 Sciences de la nature. Elle pr\u00e9sente aussi certaines applications scientifique de la programmation en Python.  Elle se divise en trois modules sur un total de 8 heures. </p> <p>Module 1 - Installation et d\u00e9marrage avec Python </p> <p>Ce module pr\u00e9sente le contexte de la programmation et quelques g\u00e9n\u00e9ralit\u00e9s sur les ordinateurs et le monde de la programmation. Le module couvre aussi l'installation des outils n\u00e9cessaires pour utiliser le langage Python ainsi que les instructions de base du langage. \u00c0 la fin de ce module, les personnes participantes peuvent \u00e9crire des programmes simples pour effectuer des op\u00e9rations arithm\u00e9tiques.</p> <p>L'exercice final sugg\u00e9r\u00e9 est l'\u00e9criture d'un programme de roche-papier-ciseau qui permet \u00e0 deux personnes de s\u00e9lectionner un symbole et d\u00e9termine la vainqueure.</p> <p> 2 heures</p> <p>Module 2 - Programmer avec Python </p> <p>Le second module approfondit l'utilisation du langage Python pour r\u00e9soudre des probl\u00e8mes en utilisant l'informatique. Le module aborde les boucles, les collections de donn\u00e9es et les fonctions. Il y est aussi trait\u00e9 des techniques de base de conception de programme, de d\u00e9boggage et de documentation. \u00c0 la fin de ce module, les personnes participantes peuvent \u00e9crire des programmes r\u00e9soudre des probl\u00e8mes en sciences et en math\u00e9matique.</p> <p> 4 heures</p> <p>Module 3 - Biblioth\u00e8ques logicielles de Python </p> <p>Le dernier module pr\u00e9sente sommairement cinq biblioth\u00e8ques de Python qui viennent augmenter les possibilit\u00e9s d'utilisation de la programmation scientifique et simplier son usage. Les cinq biblioth\u00e8ques couvertes dans ce module sont :</p> <ul> <li>Pandas : manipulation de jeu de donn\u00e9es</li> <li>Mathplotlib : tra\u00e7age de graphiques</li> <li>NumPy : d\u00e9nombrement et statistiques descriptives</li> <li>SciPy : tests d'hypoth\u00e8se</li> <li>SymPy : calcul symbolique d'\u00e9quations diff\u00e9rentiels et de syt\u00e8mes lin\u00e9aires </li> </ul> <p>\u00c0 la fin de ce module, les personnes participantes pourront \u00e9crire des programmes qui utilisent ces biblioth\u00e8ques et disposeront d'outils pour rechercher et installer d'autres biblioth\u00e8ques qui pourraient r\u00e9pondre \u00e0 d'autres contexte d'utilisation de la programmation scientifique.</p> <p> 2 heures</p>"},{"location":"#utilisation-et-partage","title":"Utilisation et partage","text":"<p>  Alexandre Ouellet, 2024</p> <p>Sauf mention contraire, tout le contenu de ce site est disponible sous licence Creative Commons Attribution - Pas d\u2019Utilisation Commerciale - Partage dans les M\u00eames Conditions 4.0 International. </p> <p>Chaque \u00e9l\u00e9ment emprunt\u00e9 est assujetti \u00e0 sa propre licence.</p>"},{"location":"installation/","title":"Pr\u00e9parer l'environnement","text":"<p>Pour suivre la formation, il est n\u00e9cessaire d'installer l'environnement de d\u00e9veloppement Thonny qui propose une interface simplifi\u00e9 pour apprendre la programmation dans le langage Python. C'est cet environnement qui sera utilis\u00e9 dans le cours 420-SN1-RE Programmation en sciences. Pour les personnes habiles avec un autre environnement de d\u00e9veloppement en Python (VSCode, PyCharm ou la ligne de commande), il est tout \u00e0 fait possible de suivre la formation avec ces environnements, mais les captures d'\u00e9crans et les proc\u00e9dures seront expliqu\u00e9es que pour l'environnement Thonny.</p>"},{"location":"installation/#installation","title":"Installation","text":"<p>Pour t\u00e9l\u00e9charger Thonny, il faut se rendre sur la page officielle de Thonny. En passant la souris au-dessus du nom du syst\u00e8me d'exploitation de votre ordinateur en haut \u00e0 gauche, vous verrez une fen\u00eatre s'ouvrir. Il faut cliquer sur le premier lien (Installer with 64-bit Python 3.10).</p> T\u00e9l\u00e9charger Thonny \u00e0 partir du site officiel <p>Une fois le t\u00e9l\u00e9chargement compl\u00e9t\u00e9, on lance l'assistant d'installation qui affiche une fen\u00eatre qui demande pour qui r\u00e9alis\u00e9 l'installation. Si vous avez les droits d'administrateur sur la machine ou que vous \u00eates la seule personne qui l'utilise je sugg\u00e8re l'option Install for all users, sinon l'option Install for me only fonctionne aussi tr\u00e8s bien. Votre syst\u00e8me d'exploitation vous affichera une notification de s\u00e9curit\u00e9 si vous avez s\u00e9lectionn\u00e9 Install for all users, il faut appuyer sur Oui pour permettre \u00e0 Thonny de s'installer. </p> S\u00e9lection des modes d'installation de Thonny <p>Ensuite, il faut suivre les \u00e9tape en appuyant sur *Next dans le bas de la fen\u00eatre jusqu'\u00e0 ce que vous ayez la fen\u00eatre suivante qui confirme l'installation correcte.</p> Confirmation d'installation avec succ\u00e8s de Thonny <p>Si vous lancez Thonny apr\u00e8s son installation, vous devriez voir s'afficher la fen\u00eatre suivante. </p> Interface au d\u00e9marrage de Thonny"},{"location":"references/","title":"R\u00e9f\u00e9rences","text":""},{"location":"references/#module-1","title":"Module 1","text":"<p>Marsyas. (2005). NAMA Machine d'Anticyth\u00e8re, Page consult\u00e9e le 14 mars 2024.</p> <p>Hello world. (2022, d\u00e9cembre 29). Wikip\u00e9dia, l'encyclop\u00e9die libre. Page consult\u00e9e le 16 mars 2024.</p>"},{"location":"module1/fonctionnement-ordi/","title":"Comment un ordinateur fonctionne-t-il ?","text":"<p> Objectifs de la section</p> <p>Expliquer sommairement le fonctionnement d\u2019un ordinateur Identifier certaines limites des ordinateurs</p> <p> Temps requis</p> <p>10 minutes</p>"},{"location":"module1/fonctionnement-ordi/#caracteristiques-des-ordinateurs","title":"Caract\u00e9ristiques des ordinateurs","text":"<p>Le premier \u00ab ordinateur \u00bb de l'histoire est la machine d'Anticyth\u00e8re (autour du III<sup>e</sup> ou du II<sup>e</sup> si\u00e8cle av. J-C) qui servait dans le calcul des \u00e9clipses. Il s'agit d'un ordinateur analogique, car il y a des donn\u00e9es (entr\u00e9e) fournies dans une machine qui ensuite exprime le r\u00e9sultat (sortie). </p> <p>La machine elle-m\u00eame effectue un calcul avec les entr\u00e9es fournies, sous le principe de la bo\u00eete noire, principe selon lequel on peut utiliser un appareil sans conna\u00eetre son fonctionnement interne. </p> Fragment de la machine d'Anticyth\u00e8re (Marsyas, 2005) <p>Cette annectode permet d'extraire les caract\u00e9ristiques qu'il est n\u00e9cessaire de constater dans un objet pour \u00eatre un ordinateur :</p> <ul> <li>Accepte des donn\u00e9es (entr\u00e9e)</li> <li>Fournit une r\u00e9ponse (sortie)</li> <li>Effectue un calcul (traitement)</li> <li>Conserve de l'information (stockage)</li> <li>Op\u00e8re automatiquement (bo\u00eete noire)</li> </ul> <p>Le m\u00e9tier d'une programmeuse ou d'un programmeur est d'utiliser les quatre premi\u00e8res caract\u00e9ristiques dans le but de concevoir une m\u00e9thode de traitement syst\u00e9matique (appel\u00e9 algorithme) des informations pour obtenir le r\u00e9sultat. Le d\u00e9veloppement d'un syst\u00e8me est donc r\u00e9alis\u00e9 en bo\u00eete blanche et n\u00e9cessite de comprendre le fonctionnement de la machine (ou du moins de certaines parties comme nous le verrons plus tard).</p>"},{"location":"module1/fonctionnement-ordi/#les-principales-composantes","title":"Les principales composantes","text":"<p>Les ordinateurs modernes sont compos\u00e9s des pi\u00e8ces suivantes :</p> <code>Carte m\u00e8re</code> La carte m\u00e8re est la pi\u00e8ce centrale de l'ordinateur. Elle relie l'information entre les diff\u00e9rentes pi\u00e8ces. C'est aussi elle qui contient le BIOS, le logiciel responsable du d\u00e9marrage de l'ordinateur. <code>Processeur</code> Le processeur effectue des comparaisons entre deux signaux \u00e9lectriques (pareil ou diff\u00e9rent) et d'inverser un signal \u00e9lectrique. Ces deux op\u00e9rations logiques peuvent \u00eatre combin\u00e9es pour obtenir l'ensemble des op\u00e9rations arithm\u00e9tiques et logiques. <code>M\u00e9moire RAM</code> La m\u00e9moire RAM est la m\u00e9moire de travail de l'ordinateur dans laquelle sont enregistr\u00e9es les donn\u00e9es sur lesquels l'ordinateur travaille. On peut voir le chargement d'un fichier dans la m\u00e9moire RAM comme laisser trainer une feuille sur son bureau. C'est plus rapide d'y avoir acc\u00e8s, mais le bordel peut s'installer rapidement. <code>M\u00e9moire secondaire (disque SSD, disque dur)</code> La m\u00e9moire secondaire est plus structur\u00e9e que la m\u00e9moire RAM, mais cette structure vient au co\u00fbt de la performance dans l'acc\u00e8s des informations. On peut voir la m\u00e9moire secondaire comme le classeur dans lequel on place toutes nos feuilles, bien organis\u00e9es par dossier et tri\u00e9es en ordre alphab\u00e9tique. Se lever pour aller consulter une feuille ou y ranger une feuille est long, mais tout est bien ordonn\u00e9. <code>Carte graphique</code> La carte graphique est un processeur sp\u00e9cialis\u00e9 dans les calculs de triangles et de certains algorithmes li\u00e9s au calcul de projections d'\u00e9l\u00e9ments tridimensionnels sur un support bidimensionnel. <code>Moniteur</code> C'est le vrai bon terme pour d\u00e9signer l'\u00e9cran. <code>P\u00e9riph\u00e9riques d'entr\u00e9e</code> Toutes les composantes qui g\u00e9n\u00e8rent un signal qui peut \u00eatre interpr\u00e9t\u00e9 par l'ordinateur (clavier, souris, manette, \u00e9cran tactile)."},{"location":"module1/fonctionnement-ordi/#le-processeur-celui-qui-soccupe-de-tout","title":"Le processeur : celui qui s'occupe de tout","text":"<p>Dans un ordinateur, tout est une comparaison ou une addition de nombres entiers. Le processeur effectue ces op\u00e9rations au niveau physique avec les signaux \u00e9lectriques (0V ou 5V). Le processeur fonctionne sur de cycles. \u00c0 chaque cycle, le processeur re\u00e7oit une information \u00e0 traiter, la traite et \u00e9met le signal \u00e9lectrique qui correspond \u00e0 la r\u00e9ponse du calcul. Les cycles sont r\u00e9gul\u00e9s par la vibration d'un cristal autour de la fr\u00e9quence 3 GHz qui permet d'effectuer, dans un cas optimal, 3 000 000 000 de calculs par secondes. </p> <p>En v\u00e9rit\u00e9, il y a toujours du temps d'attente du processeur (les autres pi\u00e8ces ne fonctionnent pas aussi rapidement), ce qui nous am\u00e8ne loin du cas optimal la plupart du temps.</p>"},{"location":"module1/fonctionnement-ordi/#x86-ou-64-bits","title":"x86 ou 64 bits ?","text":"<p>Une caract\u00e9ristique d\u00e9terminante des processeurs est la fa\u00e7on dont ils repr\u00e9sentent les nombres entiers. Tous les nombres sont repr\u00e9sent\u00e9s en donn\u00e9e binaire. On appelle bit.  chaque position d'une donn\u00e9e binaire. Les \u00ab\u00a0vieux\u00a0\u00bb syst\u00e8mes repr\u00e9sentent les entiers en utilisant 32 bits, tandis que les syst\u00e8mes modernes utilisent plut\u00f4t une repr\u00e9sentation \u00e0 64 bits. Cette repr\u00e9sentation est appel\u00e9e l'architecture du processeur. Un syst\u00e8me 64 bits permet de traiter un plus grand volume de donn\u00e9es ou des donn\u00e9es plus volumineuses lors d'un cycle du processeur qu'un processeur 32 bits ne le permet. On r\u00e9f\u00e8re souvent aux processeurs avec une architecture 32 bits comme x86.</p> <p>D'o\u00f9 vient le nom x86</p> <p>Ce nom fait r\u00e9f\u00e9rence au processeur 8086, premier processeur lanc\u00e9 en 1978 par Intel. L'architecture du 8086 est encod\u00e9e sur... 16 bits ! Le nom x86 est rest\u00e9 pour d\u00e9signer plusieurs produits d'Intel dont le num\u00e9ro se termine par 86. Comme les processeurs Intel sur une architecture 32 bits ont occup\u00e9 une large part du march\u00e9 pendant pr\u00e8s de 20 ans, le nom s'est inscrit dans les moeurs de l'informatique pour d\u00e9signer les processeurs qui op\u00e8rent sur 32 bits.</p> <p>Un processeur 64 bits peut tout \u00e0 fait ex\u00e9cuter un programme cod\u00e9 pour un processeur 32 bits; la moiti\u00e9 des bits sont simplement inutilis\u00e9s. Cela entra\u00eene une sous-utilisation du processeur et ne permet pas d'en tirer pleinement profit. Le cas inverse est cependant impossible. Un processeur op\u00e9rant sur 32 bits ne peut pas ex\u00e9cuter un programme con\u00e7u pour un processeur 64 bits, car il devrait \u00e9liminer la moiti\u00e9 des donn\u00e9es, ce qui cause \u00e9videmment des probl\u00e8mes majeurs.</p> <p>Installer des logiciels</p> <p>Plusieurs sites de t\u00e9l\u00e9chargement offrent le choix d'installer la version 32 bits (x86) ou 64 bits d'un logiciel. Il faut faire attention lors du t\u00e9l\u00e9chargement pour s\u00e9lectionner la bonne version.</p> <p>Pour savoir quelle version du processeur est install\u00e9e dans l'ordinateur, on peut acc\u00e9der aux informations du syst\u00e8me en tapant Syst\u00e8me dans la barre de recherche sur Windows 10 ou Windows 11.</p> Fen\u00eatre d'information du syst\u00e8me sur Windows 11"},{"location":"module1/fonctionnement-ordi/#concepts-cles-de-la-section","title":"Concepts cl\u00e9s de la section","text":"<code>Bo\u00eete blanche et bo\u00eete noire</code> Principe de conception selon lequel on conna\u00eet la fa\u00e7on dont les donn\u00e9es sont trait\u00e9es (bo\u00eete blanche) ou non (bo\u00eete noire). <code>Composantes de l'ordinateur</code> Plusieurs composantes sp\u00e9cialis\u00e9es interviennent dans l'ex\u00e9cution d'un programme. Les op\u00e9rations de transport des donn\u00e9es entre les composantes et les op\u00e9rations de synchronisation sont complexes et peuvent occasionner des ralentissements dans l'ex\u00e9cution. <code>Architectures</code> Certains programmes sont con\u00e7us pour s'ex\u00e9cuter sur certains types de processeurs. Il faut \u00eatre attentif lors de l'installation du logiciel pour s\u00e9lectionner la bonne version."},{"location":"module1/langage_programmation/","title":"Le r\u00f4le et la structure des langages de programmation","text":"<p> Objectifs de la section</p> <p>Reconna\u00eetre les principales abstractions et couches logicielles Expliquer l'utilisation et de l'interpr\u00e9tation des langages de programmation</p> <p> Temps requis</p> <p>10 minutes</p>"},{"location":"module1/langage_programmation/#les-langages-de-programmation","title":"Les langages de programmation","text":"<p>Bien que les machines fonctionnent \u00e0 l'aide de signaux \u00e9lectriques repr\u00e9sent\u00e9s par les structures binaires (0 pour l'absence de courant \u00e9lectrique et 1 pour un courant \u00e9lectrique), il est rarissime qu'il faille interagir \u00e0 ce niveau pour r\u00e9aliser une t\u00e2che. Bien souvent, on utilise un langage de programmation qui permet d'exprimer des concepts \u00e0 l'aide d'un langage lisible et interpr\u00e9table par les \u00eatres humains. Les \u00ab\u00a0textes\u00a0\u00bb \u00e9crits avec ce langage sont appel\u00e9s code source et le r\u00e9sultat de leur transformation en code utilisable par la machine est appel\u00e9 programme ou logiciel. </p> Exemple de programme simple avec Python<pre><code>def main():\n    try:\n        nombre = int(input(\"Saisissez un nombre entier, puis appuyez sur \\\"Entr\u00e9e\\\": \"))\n\n        if nombre &gt; 0:\n            print(\"Le nombre entr\u00e9 est positif.\")\n        elif nombre &lt; 0:\n            print(\"Le nombre entr\u00e9 est n\u00e9gatif.\")\n        else:\n            print(\"Le nombre entr\u00e9 est 0.\")\n\n    except ValueError:\n        print(\"Vous n'avez pas entr\u00e9 un nombre entier.\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>On trouve plusieurs dizaines de langages de programmation standard, certains plus g\u00e9n\u00e9raux et d'autres sp\u00e9cialis\u00e9s pour remplir une fonction ou manipuler un type d'information particulier. Tous les langages ont en commun qu'ils d\u00e9finissent une syntaxe (r\u00e8gles d'\u00e9criture des \u00ab\u00a0phrases\u00a0\u00bb la langue), une s\u00e9mantique (sens donn\u00e9 aux termes et aux structures) et un lexique (\u00ab\u00a0mots\u00a0\u00bb qui existent dans la langue). Le choix d'un langage plut\u00f4t qu'un autre repose souvent sur le lexique natif du langage ou des outils d\u00e9velopp\u00e9s avec le langage qui vient \u00e9tendre le lexique natif du langage.  Les langages offrent, pour la plupart, des fa\u00e7ons de lire des donn\u00e9es, de transmettre des donn\u00e9es, de traiter des donn\u00e9es et de stocker des donn\u00e9es. Ces quatre fonctionnalit\u00e9s correspondent aux quatre caract\u00e9ristiques des ordinateurs.</p> <p>L'une des plus grandes difficult\u00e9s dans l'apprentissage d'un langage de programmation est l'apprentissage de la s\u00e9mantique, qui repose elle-m\u00eame sur deux concepts : l'abstraction et les paradigmes.</p>"},{"location":"module1/langage_programmation/#labstraction-et-les-paradigmes-dans-le-langage-de-linformatique","title":"L'abstraction et les paradigmes dans le langage de l'informatique","text":"<p>Les termes abstraction et paradigme sont souvent utilis\u00e9s pour expliquer la fa\u00e7on dont les langages de programmation nous am\u00e8nent \u00e0 r\u00e9fl\u00e9chir. D'autres utilisent ces termes pour expliquer comment il faut r\u00e9fl\u00e9chir pour exprimer une id\u00e9e dans un langage de programmation. Bien qu'il s'agisse un peu du probl\u00e8me de l'oeuf et de la poule, ces deux concepts sont essentiels \u00e0 la bonne compr\u00e9hension des langages de programmation.</p> <p>Abstraction</p> <p>Une abstraction est une repr\u00e9sentation d'un concept tangible ou non avec une construction logicielle. Par exemple, un fichier est une abstraction d'une feuille de papier. Le fichier ne partage aucune caract\u00e9ristique commune avec la feuille de papier autre que les deux servent \u00e0 rassembler des informations \u00e0 un m\u00eame endroit. Pourtant, le fichier exerce exactement la m\u00eame fonction dans un ordinateur qu'une feuille de papier.</p> <p>Nous verrons quand nous utiliserons un langage de programmation que chaque repr\u00e9sentation d'un objet ou d'un concept du monde r\u00e9el n\u00e9cessitera l'utilisation d'une abstraction donn\u00e9e par le langage.</p> <p>Paradigme</p> <p>Pris dans un dictionnaire, le terme paradigme a une d\u00e9finition qui s'approche souvent de \u00ab mod\u00e8le de pens\u00e9e \u00bb ou encore \u00ab conception th\u00e9orique d'un domaine \u00bb. Les paradigmes en informatique orientent la fa\u00e7on dont on exprime nos concepts. On exprime que l'on travaille dans un paradigme particulier pour identifier les abstractions principales que l'on utilise. Par exemple, le langage Python emploie plusieurs paradigmes, dont le paradigme imp\u00e9ratif (on donne des directives pour changer l'\u00e9tat du programme) et le paradigme structur\u00e9 (constructions pour assurer le contr\u00f4le du programme). Donc, pour travailler avec Python, il faut exprimer ces id\u00e9es \u00e0 l'aide des abstractions fournies par le langage pour assurer le contr\u00f4le des donn\u00e9es et les changements d'\u00e9tat du programme.</p> <p>Cette d\u00e9finition peut sembler floue \u00e0 ce stade, mais deviendra beaucoup plus concr\u00e8te en travaillant quelques probl\u00e8mes.</p>"},{"location":"module1/langage_programmation/#les-principales-couches-logicielles","title":"Les principales couches logicielles","text":"<p>Comme mentionn\u00e9 pr\u00e9c\u00e9demment, peu de personnes codent des programmes qui interagissent directement avec des composantes mat\u00e9rielles. On s'appuie plut\u00f4t sur des programmes existants pour faciliter l'\u00e9criture des programmes. La figure ci-dessous illustre 4 des couches pertinentes dans le d\u00e9veloppement d'un programme Python.</p> <pre><code>graph TD\n    A[Programme Python] --&gt; E[Interpr\u00e9teur Python] --&gt; B[Syst\u00e8me d'exploitation] --&gt; D[Couche mat\u00e9rielle]</code></pre> Les diff\u00e9rentes couches logicielles <p>La couche la plus \u00e9lev\u00e9e, Programme Python, correspond au programme \u00e9crit et que l'on souhaite utiliser. On dit alors que Python est un langage de haut niveau. Le code source de ce fichier est transmis \u00e0 l'interpr\u00e9teur Python qui transforme le code code source lisible par les humains en une s\u00e9rie d'instructions destin\u00e9es au syst\u00e8me d'exploitation (couche suivante). L'interpr\u00e9teur est le programme \u00ab\u00a0python 3.12.exe\u00a0\u00bb que nous installerons lors de la prochaine section. Sans ce programme, les codes \u00e9crits en Python ne peuvent \u00eatre trait\u00e9s par la machine. </p> <p>Le syst\u00e8me d'exploitation est le logiciel responsable de l'organisation et de la gestion des ressources d'un ordinateur. Ils sont principalement issus de l'une des trois grandes familles : Windows, Mac ou Linux. Chacun des syst\u00e8mes d'exploitation d\u00e9finit un jeu d'instructions diff\u00e9rent (mais qui fait sensiblement la m\u00eame chose). Sans notre interpr\u00e9teur il faudrait \u00e9crire un programme diff\u00e9rent pour chaque syst\u00e8me d'exploitation. Il peut quand m\u00eame exister des diff\u00e9rences l\u00e9g\u00e8res et rares entre un programme d\u00e9velopp\u00e9 pour deux syst\u00e8mes d'exploitation diff\u00e9rents (principalement entre Windows et les autres), mais elles se g\u00e8rent facilement et elles entra\u00eenent rarement des probl\u00e8mes bloquants.</p> Syst\u00e8me d'exploitation <p>En anglais, le terme Operating System est employ\u00e9 pour d\u00e9signer le syst\u00e8me d'exploitation. M\u00eame en fran\u00e7ais nous avons tendance \u00e0 faire r\u00e9f\u00e9rence au syst\u00e8me d'exploitation en utilisant l'acronyme OS.  </p> <p>Finalement, le syst\u00e8me d'exploitation transmet les instructions aux composantes mat\u00e9rielles qui les ex\u00e9cutent. Dans les faits, il peut y avoir plusieurs couches interm\u00e9diaires entre le syst\u00e8me d'exploitation et les composantes mat\u00e9rielles. Chaque couche utilise un jeu d'instructions de plus en plus \u00e9l\u00e9mentaire. Ce n'est toutefois pas n\u00e9cessaire de s'y int\u00e9resser pour comprendre le fonctionnement d'un langage de haut niveau comme Python.</p>"},{"location":"module1/langage_programmation/#concepts-cles-de-la-section","title":"Concepts cl\u00e9s de la section","text":"<code>Langage de programmation</code> Langage compr\u00e9hensible par des humains qui sert \u00e0 exprimer la structure d'un programme ex\u00e9cutable par un ordinateur.  <code>Abstraction</code> Repr\u00e9sentation d'un concept tangible ou tir\u00e9 du monde r\u00e9el par une construction logicielle. <code>Syst\u00e8me d'exploitation</code> Programme qui g\u00e8re l'acc\u00e8s aux ressources de la machine. <code>Interpr\u00e9tation d'un code source</code> Op\u00e9ration dans laquelle un code source est transform\u00e9 en instructions qui peuvent \u00eatre trait\u00e9es par la machine (en particulier son syst\u00e8me d'exploitation)."},{"location":"module1/syntaxe_base/","title":"La syntaxe de base de Python","text":"<p> Objectifs de la section</p> <p>D\u00e9clarer de la fonction main et le point d\u2019entr\u00e9e du programme Ex\u00e9cuter les op\u00e9rations de lecture et d'\u00e9criture en console Manipuler les variables repr\u00e9sentant des nombres entiers D\u00e9clarer et concat\u00e9ner des cha\u00eenes de caract\u00e8re</p> <p> Temps requis</p> <p>30 minutes</p>"},{"location":"module1/syntaxe_base/#le-squelette-dun-programme-python","title":"Le squelette d'un programme Python","text":"<p>Dans l'\u00e9criture d'un programme en Python, il y a deux grandes familles d'instruction :</p> <ol> <li>Les instructions de d\u00e9claration ( all\u00f4 j'existe !) qui servent \u00e0 d\u00e9finir un \u00e9l\u00e9ment; et</li> <li>Les instructions imp\u00e9ratives qui r\u00e9alise des op\u00e9rations.</li> </ol> <p>Prenons la structure du programme tr\u00e8s simple suivant.</p> Structure minimale d'un programme Python<pre><code>def main():\n    # On d\u00e9finit ici quelque chose \u00e0 faire\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>La premi\u00e8re ligne <code>def main():</code> indique que l'on d\u00e9finit une fonction appel\u00e9e <code>main</code>. Le symbole deux points (\u00a0:\u00a0) en python introduit un bloc de code. Tout ce qui suit le deux-points et qui est plus indent\u00e9 est dans le bloc de code. Donc ici la fonction main contient tout ce qui suit est qui est indent\u00e9 d'un niveau ou plus.</p> <p>La quatri\u00e8me ligne <code>if __name__ == \"__main__\":</code> repr\u00e9sente le point d'entr\u00e9e du programme. C'est une ligne de code sp\u00e9ciale qui permet \u00e0 l'interpr\u00e9teur de Python de savoir o\u00f9 commencer \u00e0 lire le code. La cinqui\u00e8me ligne <code>main()</code> est une instruction imp\u00e9rative d'ex\u00e9cuter le code d\u00e9finit dans la structure <code>main</code>.</p> <p>Commentaire</p> <p>Toutes les lignes de code qui commencent par <code>#</code> sont des commentaires. Un commentaire n'est pas interpr\u00e9t\u00e9 par Python (en fait il est simplement ignor\u00e9), mais permet \u00e0 nous, \u00eatres humains, d'ajouter des compl\u00e9ments d'information dans le code qui s'av\u00e8rent souvent fort utile pour en comprendre le sens.</p> <p>Un niveau d'indentation en Python correspond \u00e0 4 espaces. La plupart des IDE remplacent une tabulation Tab par 4 espaces. Il est aussi possible de conserver le caract\u00e8re tabulation (m\u00eame si ce n'est pas recommand\u00e9), il faut simplement que la fa\u00e7on d'indenter soit uniforme dans un fichier.</p>"},{"location":"module1/syntaxe_base/#ecrire-dans-la-console","title":"\u00c9crire dans la console","text":"<p>La fonction <code>print</code> permet d'afficher une cha\u00eene de caract\u00e8re dans la console. On d\u00e9limite le contenu d'une cha\u00eene de caract\u00e8re avec des guillemets anglais (\u00a0\"\u00a0). Le premier programme en information est le programme appel\u00e9 Hello, World !  qui affiche simplement cette salutation.</p> Programme Hello, World!<pre><code>def main():\n    print(\"Hello, World!\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Mettre un guillemet dans une cha\u00eene de caract\u00e8re</p> <p>Comme le caract\u00e8re guillemet (\u00a0\"\u00a0) repr\u00e9sente la limite de la cha\u00eene, il faut ajouter une barre oblique inverse (backslash) devant pour indiquer que le guillemet ne signifie pas la fin de la cha\u00eene. C'est ce que l'on appelle \u00ab\u00a0\u00e9chapper\u00a0\u00bb le caract\u00e8re.</p> <p>Cha\u00eene valide : <code>\"Comme le dit si bien le grand Homer Simpson : \\\"Where is the 'any' key ?\\\"\"</code></p> <p>Cha\u00eene erron\u00e9e : <code>\"Comme le dit si bien le grand Homer Simpson : \"Where is the 'any' key ?\"\"</code></p> Guillemets simples ou doubles <p>Python supporte de fa\u00e7on interchangeable les guillemets anglais simples (caract\u00e8re de l'apostrophe) ou doubles pour les cha\u00eenes de caract\u00e8re. Il est souvent plus simple d'utiliser les guillemets doubles, car sinon il faut \u00e9chapper toutes les apostrophes.</p> <p>Cha\u00eene valide : <code>'Comme le dit si bien le grand Homer Simpson : \"Where is the \\'any\\' key ?\"'</code></p> <p>Dans plusieurs autres langages de programmation, les guillemets simples ou doubles ont une signification diff\u00e9rente et les guillemets doubles servent \u00e0 traiter les cha\u00eenes de caract\u00e8res. Utiliser cette convention peut aussi faciliter le passage \u00e0 d'autres langages de programmation.  </p>"},{"location":"module1/syntaxe_base/#executer-un-programme","title":"Ex\u00e9cuter un programme","text":"Dans Thonnny\u00c0 partir de l'invite de commande <p> Ex\u00e9ctuer un programme dans Thonny <p>Pour ex\u00e9cuter un programme, on \u00e9crit d'abord le script (duh...) dans la partie sup\u00e9rieure \u00e0 gauche de l'interface. Il est possible de sauvegarder ou d'ouvrir le script d'un programme (attention, ici on sauvegarde les instructions et non le r\u00e9sultat !).</p> <p>Pour ex\u00e9cuter les inscriptions, on lance avec la fl\u00e8che verte (dans le carr\u00e9 rouge sur la capture d'\u00e9cran pr\u00e9c\u00e9dente). Le r\u00e9sultat s'affiche dans la section du bas (appel\u00e9e console).</p> <p> R\u00e9sultat de l'ex\u00e9cution du programme hello-world.py <p>Il est aussi possible de lancer un programme python sans IDE. Pour se faire il faut ouvrir une invite de commande (cmd ou PowerShell dans Windows ou dans le terminal pour Linux ou Mac).</p> <p>Il faut d'abord se positionner au bon endroit sur le disque avec la commande cd puis ex\u00e9cuter le programme python (ou simplement py) en lui donnant comme argument le nom du fichier python.</p> <pre><code>C:/users/moi&gt; cd C:/repetoire/du/fichier/.py/\nC:/repetoire/du/fichier/.py/&gt; python nom_fichier.py\n</code></pre> <p>La commande python n'est pas trouv\u00e9e</p> <p>V\u00e9rifier la variable PATH et assurez-vous que l'ex\u00e9cutable de python y figure\u00e9</p>"},{"location":"module1/syntaxe_base/#les-variables-et-les-identificateurs","title":"Les variables et les identificateurs","text":"<p>Les variables en Python servent \u00e0 contenir l'information d'un type donn\u00e9. Les variables poss\u00e8dent toutes un identificateur qui est utilis\u00e9 pour les manipuler et acc\u00e9der \u00e0 leur contenu. Les valeurs contenues dans les variables peuvent changer durant l'ex\u00e9cution d'un programme, mais elles doivent toujours \u00eatre de m\u00eame type dans une m\u00eame variable.</p>"},{"location":"module1/syntaxe_base/#identificateurs","title":"Identificateurs","text":"<p>Plusieurs abstractions n\u00e9cessitent d'\u00eatre nomm\u00e9es pour y faire appel dans le code (comme les variables ou les fonctions). Le langage Python d\u00e9finit 4 r\u00e8gles pour la fa\u00e7on de choisir les identificateurs. Le non-respect de ces r\u00e8gles entra\u00eene des erreurs dans l'ex\u00e9cution du script.</p> <p>Tous les identificateurs en Python doivent respecter ces quatre r\u00e8gles : </p> <ol> <li>Ils commencent par une lettre majuscule, minuscule ou un trait de soulignement;</li> <li>Les identificateurs sont compos\u00e9s de lettres, de chiffres et de traits de soulignement (\u00a0_\u00a0);</li> <li>Les identificateurs sont sensibles \u00e0 la casse (a \\(\\neq\\) A); et</li> <li>Les identificateurs doivent \u00eatre diff\u00e9rents des mots cl\u00e9s r\u00e9serv\u00e9s par le langage.</li> </ol> <p>Mots cl\u00e9s r\u00e9serv\u00e9s dans le langage Python</p> <pre><code>False      await      else       import     pass\nNone       break      except     in         raise\nTrue       class      finally    is         return\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\n</code></pre> <p>Le choix d'un identificateur</p> <p>Tous les identificateurs doivent \u00eatre significatifs. Par exemple, si l'on veut conserver en m\u00e9moire une information sur la concentration d'acide ac\u00e9tique d'une solution, la variable qui contient cette information peut s'appeler <code>concentration</code>, <code>concentration_acide</code> ou <code>concentration_CH3COOH</code> par exemple. Les identificateurs comme <code>x</code>, <code>conc_acide</code>, <code>ma_concentration_d_acide_acetique</code> ou <code>bob</code> ne renseignent pas sur la signification de cette variable ou sont inutilement longs.</p>"},{"location":"module1/syntaxe_base/#regles-de-style-pour-les-identificateurs-de-variables","title":"R\u00e8gles de style pour les identificateurs de variables","text":"<p>Pour l'\u00e9criture d'un identificateur de variable, il faut respecter les 2 r\u00e8gles : </p> <ol> <li>On n'utilise pas de lettres majuscules dans les noms de variables, sauf si la lettre majuscule \u00e0 un sens important; et</li> <li>Si l'identificateur comporte plusieurs mots, on place un trait de soulignement (\u00a0_\u00a0) entre chaque mot (c'est ce qui s'appelle le snake_case).</li> </ol> <p>Le non-respect de ces r\u00e8gles n'entra\u00eene pas d'erreur dans l'ex\u00e9cution du script, mais diminue la lisibilit\u00e9 du code.</p>"},{"location":"module1/syntaxe_base/#declarer-une-variable-de-type-numerique-et-effectuer-des-operations-arithmetiques","title":"D\u00e9clarer une variable de type num\u00e9rique et effectuer des op\u00e9rations arithm\u00e9tiques","text":"<p>Pour d\u00e9clarer une variable, on lui assigne un identificateur valide et puis on indique le symbole d'\u00e9galit\u00e9 (\u00a0=\u00a0) puis la valeur initiale de la variable.</p> <pre><code>variable = 2\n</code></pre> <p>Les op\u00e9rations arithm\u00e9tiques suivantes peuvent \u00eatre appliqu\u00e9es sur les types num\u00e9riques.</p> Op\u00e9ration Op\u00e9rateur Exemple d'utilisation Addition + <code>1 + 1 # R\u00e9sultat : 2</code> Soustraction - <code>2 - 1 # R\u00e9sultat : 0</code> Multiplication * <code>-1 * 2 # R\u00e9sultat : -2</code> Exponentiation ** <code>2 ** 3 # R\u00e9sultat : 8</code> Division / <code>3 / 2 # R\u00e9sultat : 1.5</code> Division enti\u00e8re // <code>11 // 3 # R\u00e9sultat : 3</code> Modulo (reste de la division enti\u00e8re) % <code>11 % 3 # R\u00e9sultat : 2</code> <p>Entiers et d\u00e9cimaux</p> <p>Les nombres d\u00e9cimaux (\u00e0 virgule) sont trait\u00e9s diff\u00e9remment des nombres entiers et il faut faire attention quand on les utilise, car cela vient avec certaines implications. Les nombres d\u00e9cimaux sont couverts dans la prochaine section.</p> <p>Par exemple, la division enti\u00e8re et le modulo peuvent se comporter de fa\u00e7on inattendue avec des nombres d\u00e9cimaux.</p>"},{"location":"module1/syntaxe_base/#declarer-une-variable-de-type-chaine-de-caracteres-et-concatener-des-chaines-de-caracteres","title":"D\u00e9clarer une variable de type cha\u00eene de caract\u00e8res et concat\u00e9ner des cha\u00eenes de caract\u00e8res","text":"<p>D\u00e9clarer une variable de type cha\u00eene de caract\u00e8res est similaire \u00e0 d\u00e9clarer une variable enti\u00e8re. On donne \u00e0 la variable un identificateur puis le symbole d'\u00e9galit\u00e9 et la valeur de la cha\u00eene en guillemets anglais.</p> <pre><code>variable_chaine = \"Bonjour\"\n</code></pre>"},{"location":"module1/syntaxe_base/#concatenation-de-chaines","title":"Concat\u00e9nation de cha\u00eenes","text":"<p>L'op\u00e9ration de concat\u00e9nation permet de combiner des cha\u00eenes de caract\u00e8res. On utilise l'op\u00e9rateur d'addition (\u00a0+\u00a0) pour exprimer dans le langage Python l'id\u00e9e de la concat\u00e9nation. </p> <pre><code>texte_accueil = \"Bonjour\"\nnom_personne_1 = \"Alice\"\nbonjour_alice = texte_accueil + nom_personne_1\n\nprint(bonjour_alice)        # Affiche BonjourAlice\n</code></pre> <p>On voit que le r\u00e9sultat <code>BonjourAlice</code> n'est pas exactement conforme \u00e0 nos attentes. Tous les caract\u00e8res (espaces, retour \u00e0 la ligne, tabulations) doivent \u00eatre ajout\u00e9s manuellement \u00e0 la cha\u00eene de caract\u00e8res pour s'afficher (et tous les caract\u00e8res ajout\u00e9s s'affichent...).</p> Caract\u00e8re d'espacement Symbole Espace \" \" Tabulation \"\\t\" Retour \u00e0 la ligne \"\\n\""},{"location":"module1/syntaxe_base/#afficher-des-variables-numeriques-dans-une-chaine-de-caracteres","title":"Afficher des variables num\u00e9riques dans une cha\u00eene de caract\u00e8res","text":"<p>La ligne de code suivante provoque une erreur lors de son ex\u00e9cution.</p> <pre><code>print(\"Valeur : \" + 5)          # N'affiche pas \"Valeur : 5\" \n</code></pre> <p>Erreur</p> <p>TypeError: can only concatenate str (not \"int\") to str</p> <p>Pour r\u00e9gler cette erreur, il faut utiliser la fonction <code>str</code> (la version raccourcie du terme string, cha\u00eene de caract\u00e8res).</p> <pre><code>print(\"Valeur : \" + str(5))          # Fonctionne \u00e0 merveille \ud83d\udc4d\n</code></pre>"},{"location":"module1/syntaxe_base/#lire-une-information-de-la-console","title":"Lire une information de la console","text":"<p>Pour r\u00e9cup\u00e9rer une information saisie par la personne utilisatrice, on utilise la fonction <code>input()</code> qui lit ce qui est entr\u00e9 dans la console jusqu'\u00e0 symbole de retour \u00e0 la ligne (touche Enter). Il faut stocker le r\u00e9sultat de la fonction dans une variable pour pouvoir l'utiliser par la suite. </p> <p>Le r\u00e9sultat de <code>input()</code> est toujours une cha\u00eene de caract\u00e8re. Par exemple, si l'on entre \u00ab\u00a05\u00a0\u00bb au clavier, la valeur est stock\u00e9e dans la cha\u00eene contenant le caract\u00e8re 5 et non commen la valeur num\u00e9rique 5. Pour transformer une cha\u00eene de caract\u00e8re en valeur num\u00e9rique enti\u00e8re, il faut utiliser la fonction <code>int()</code> (la version raccourcie du terme integer, entier).</p> <pre><code>saisie = input()        # Imaginons que 1 est entr\u00e9, alors saisie \n                        # contient \"1\"\nvaleur = int(saisie)    # valeur contient maintenant la valeur \n                        # num\u00e9rique 1\n\nsaisie + 1              # Erreur, on ne peut pas additionner une cha\u00eene\n                        # et un entier \ud83d\udc4e\nvaleur + 1              # Tout \u00e0 fait valide, on peut additionner deux\n                        # entiers \ud83d\udc4d\n</code></pre>"},{"location":"module1/syntaxe_base/#un-premier-programme","title":"Un premier programme","text":"<p>Demandez \u00e0 une personne utilisatrice de saisir deux nombres entiers dans la console, multipliez ces nombres et affichez le produit obtenu.</p> Solution super-duper-additionner.py<pre><code>def main():\n    # Saisie des informations\n    print(\"Entrez le premier nombre a multiplier :\")\n    operande_gauche = int(input())\n\n    print(\"Entrez le second nombre a multiplier :\")\n    operande_droite = int(input())\n\n    # Calcul et affichage\n    produit = operande_gauche * operande_droite\n    print(\"Le produit est : \" + str(produit))\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"module1/syntaxe_base/#concepts-cles-de-la-section","title":"Concepts cl\u00e9s de la section","text":"<code>d\u00e9claration</code> op\u00e9ration dans lequelle on indique dans le langage de programmation l'existence d'une certaine structure (variable, fonction...) <code>indentation</code> espace ajout\u00e9 devant une ligne. En python l'idententation est un groupe de quatre espaces ou d'une tabulation (elle doit \u00eatre constante dans un fichier). On parle de niveaux d'indentation lorsque ajoute plusieurs groupe de quatre espaces ou tabulations. <code>point d'entr\u00e9e</code> premier \u00e9l\u00e9ment du programme qui est ex\u00e9cut\u00e9.  <code>variable</code> abstraction qui repr\u00e9sente une donn\u00e9e atomique (nombre entier, d\u00e9cimal, cha\u00eene de caract\u00e8re...). Chaque variable peut \u00eatre poss\u00e8de un identificateur unique."},{"location":"module1/syntaxe_base/#les-fonctions-vues-dans-cette-section","title":"Les fonctions vues dans cette section","text":"<code>int</code> converti une cha\u00eene de caract\u00e8res en entier. <code>input</code> lit une cha\u00eene de caract\u00e8res dans la console. <code>main</code> repr\u00e9sente le point d'entr\u00e9e du programme. <code>print</code> affiche une cha\u00eene de caract\u00e8res dans la console. <code>str</code> retourne la repr\u00e9sentation d'une variable sous forme de cha\u00eene de caract\u00e8res."},{"location":"module1/types_logique_arithmetique/","title":"Types de donn\u00e9es, op\u00e9rations et conditions logiques","text":"<p> Objectifs de la section</p> <p>Manipuler des donn\u00e9es dans les types natifs Effectuer un traitement conditionnel Exprimer des conditions logiques \u00e0 l'aide d'expressions bool\u00e9ennes compos\u00e9es</p> <p> Temps requis</p> <p>50 minutes</p> <p>Tel que vu \u00e0 la section pr\u00e9c\u00e9dente, il existe diff\u00e9rents types aux donn\u00e9es que l'on manipule. Les fonctions et les op\u00e9rations s'attendent \u00e0 recevoir des donn\u00e9es dans certains types, il faut donc s'assurer de les respecter. Le langage python est dit typ\u00e9 :</p> <ul> <li>fort : on ne peut pas m\u00e9langer les types de donn\u00e9es, il faut faire les conversions explicites; et</li> <li>dynamique : on ne pr\u00e9cise pas le type dans la d\u00e9claration de la variable, il est d\u00e9duit par l'interpr\u00e9teur de python.</li> </ul> <p>Concr\u00e8tement, cela signifie que l'on ne peut pas par exemple additionner une cha\u00eene de caract\u00e8res et un entier, mais on peut assigner une cha\u00eene de caract\u00e8res \u00e0 une variable, puis remplacer cette valeur par un entier, et ce, dans la m\u00eame variable.</p> Typage des variables<pre><code>chaine = \"Allo\"\nvaleur = 5\n\n# Ce bout de code est invalide\nprint(valeur + chaine)\n\n# Ce bout de code est valide\nvaleur = \"valeur\"\n</code></pre>"},{"location":"module1/types_logique_arithmetique/#types-de-donnees","title":"Types de donn\u00e9es","text":"<p>On trouve en python les types de donn\u00e9es suivants :</p> <ul> <li>Nombres entiers;</li> <li>Nombres \u00e0 virgule flottante;</li> <li>Cha\u00eenes de caract\u00e8res;</li> <li>Bool\u00e9ens (variables logiques);</li> <li>Tableaux (vus au module 2);</li> <li>Structures de donn\u00e9es (vues au module 2); et</li> <li>Classes (pas vues dans la formation).</li> </ul>"},{"location":"module1/types_logique_arithmetique/#nombres-entiers","title":"Nombres entiers","text":"<p>Les nombres entiers sont repr\u00e9sent\u00e9s en format binaire (compos\u00e9 de 0 et de 1). Le binaire fonctionne comme le syst\u00e8me d\u00e9cimal, mais au lieu de compter en base 10, on compte en base 2.</p> <p>Par exemple le nombre 101 en d\u00e9cimale est en fait la somme suivante : \\(101 = 1 \\times 10^2 + 0 \\times 10^1 + 1 \\times 10^0\\)</p> <p>Le m\u00eame nombre en binaire repr\u00e9sente plut\u00f4t la somme suivante : \\(101 = 1 \\times 2^2 + 0 \\times 2^1 + 1 \\times 2^0\\) ... soit la valeur 5 en base d\u00e9cimale.</p> <p>Les entiers en python, contrairement \u00e0 bien des langages de programmation, sont encod\u00e9s sur un nombre de bits variable, ce qui \u00e9vite les erreurs de d\u00e9bordement (overflow) constat\u00e9es avec d'autres langages.</p>"},{"location":"module1/types_logique_arithmetique/#nombres-a-virgule-flottante","title":"Nombres \u00e0 virgule flottante","text":"<p>Les nombres \u00e0 virgule (appel\u00e9s virgule flottante en informatique) sont \u00e9galement repr\u00e9sent\u00e9s en binaire, \u00e0 l'aide d'un masque. Le passage de la base d\u00e9cimale en la base binaire se fait moins naturellement que pour les entiers \u00e0 cause du changement des nombres \u00e0 repr\u00e9sentation p\u00e9riodique. </p> <p>Par exemple en base 10, on \u00e9crit souvent la fraction \\(\\frac{1}{3}\\) comme 0.33 ou 0.333 ... selon le degr\u00e9 de pr\u00e9cision souhait\u00e9. Cet arrondi cause des erreurs arithm\u00e9tiques qui s'accumulent lors des calculs num\u00e9riques. En binaire, le m\u00eame ph\u00e9nom\u00e8ne se produit, mais sur des valeurs diff\u00e9rentes. Par exemple la fraction \\(\\frac{1}{10}\\) est repr\u00e9sent\u00e9e en binaire par 0.0011 0011 0011 (0011) r\u00e9p\u00e9t\u00e9 \u00e0 l'infini, donc est aussi arrondi et cause des erreurs arithm\u00e9tiques. Par exemple, \\(\\frac{1}{10} + \\frac{1}{10} + \\frac{1}{10} = 0.30000000000000004\\).</p> <p>De plus, la repr\u00e9sentation en virgule flottante exploite la notation scientifique. Donc la pr\u00e9cision est autour de la virgule (d'o\u00f9 le nom virgule flottante) et il est possible de perdre une partie de l'information pour les grands nombres. Python pr\u00e9sente que les 17 premi\u00e8res d\u00e9cimales d'un nombre, m\u00eame si plus sont calcul\u00e9es. Les nombres d\u00e9cimaux doivent \u00eatre 2.2250738585072014e-308 entre 1.7976931348623157e+308.</p>"},{"location":"module1/types_logique_arithmetique/#representation-des-types-logiques","title":"Repr\u00e9sentation des types logiques","text":"<p>On utilise souvent en informatique des variables bool\u00e9ennes, c'est-\u00e0-dire qu'elles peuvent prendre que la valeur vraie (True) ou fausse (False). Ce type de valeurs est tr\u00e8s utile pour se traiter un \u00e9tat ou un param\u00e8tre d'un syst\u00e8me. On peut aussi s'en servir dans des expressions logiques afin de construire des expressions complexes.</p> <p>La majuscule</p> <p>Il est important de porter attention \u00e0 la majuscule, car le langage Python est sensible \u00e0 la casse. Par exemple, true provoque une erreur, tandis que True est une expression valide.   </p>"},{"location":"module1/types_logique_arithmetique/#representation-de-rien-pantoute","title":"Repr\u00e9sentation de rien pantoute","text":"<p>Il peut arriver que l'on doive d\u00e9clarer une variable, mais qu'on ne connaisse pas le contenu de celle-ci au moment de la d\u00e9claration. On peut utiliser le mot-cl\u00e9 None pour indiquer que son contenu est vide.</p> D\u00e9claration d'une variable vide<pre><code>variable = None\n</code></pre>"},{"location":"module1/types_logique_arithmetique/#afficher-le-type-dune-variable","title":"Afficher le type d'une variable","text":"<p>Pour conna\u00eetre le type d'une variable \u00e0 un certain moment, on utilise la fonction <code>!# type()</code> qui affiche dans la console le type de la donn\u00e9e.</p> Type de la donn\u00e9e Exemple de donn\u00e9e Affichage dans la console Entier 2 &lt;class 'int'&gt; Virgule flottante 5.4 &lt;class 'float'&gt; Bool\u00e9en True &lt;class 'bool'&gt; Cha\u00eene de caract\u00e8res 'Bob' &lt;class 'str'&gt; Vide None &lt;class 'NoneType'&gt;"},{"location":"module1/types_logique_arithmetique/#conversion-entre-les-types","title":"Conversion entre les types","text":"<p>On peut faire des conversions entre les types, par exemple transform\u00e9e une cha\u00eene de caract\u00e8re lue en un entier. C'est ce qui a \u00e9t\u00e9 fait \u00e0 l'exercice de la section pr\u00e9c\u00e9dente o\u00f9 l'on appelait la fonction <code>int</code> sur une cha\u00eene de caract\u00e8res. Les fonctions sont toujours les m\u00eames que les types de donn\u00e9es :</p> <ul> <li>Entier : <code>int</code></li> <li>Virgule flottant : <code>float</code></li> <li>Bool\u00e9en : <code>bool</code></li> <li>Cha\u00eene de caract\u00e8res : <code>str</code></li> </ul> <p>Conversion vers None</p> <p>Il est impossible de convertir vers ou \u00e0 partir du type <code>None</code> : il n'y a pas de donn\u00e9es \u00e0 convertir.</p> <p>Le tableau ci-dessous explique le fonctionnement des conversions. Notez que les conversions incoh\u00e9rentes provoquent des erreurs, par exemple <code>int(\"patate\")</code>. Les colonnes pr\u00e9sentent le type d'origine, les lignes le type vers lequel on convertit.</p> Type destination  Type converti Entier Virgule flottante Cha\u00eene de caract\u00e8re Bool\u00e9en Entier Troncature des d\u00e9cimales Conversion seulement si la cha\u00eene contient un entier. True vaut 1 et False vaut 0. Virgule flottante Conversion sans perte d'information Conversion seulement si la cha\u00eene contient un nombre. Attention au s\u00e9parateur des d\u00e9cimales. Cha\u00eene de caract\u00e8re Repr\u00e9sentation sous forme de cha\u00eene Repr\u00e9sentation sous forme de cha\u00eene en notation scientifique possiblement \u00c9criture des termes \u00ab\u00a0True\u00ab\u00a0\u00bb ou \u00ab\u00a0False\u00ab\u00a0\u00bb Bool\u00e9en 0 est False, tous les autres entiers sont True 0.0 est False, tous les autres nombres sont True La cha\u00eene vide est False, toutes les autres sont True"},{"location":"module1/types_logique_arithmetique/#instruction-conditionnelle","title":"Instruction conditionnelle","text":"<p>L'une des caract\u00e9ristiques les plus importantes des programmes est de r\u00e9agir de fa\u00e7on diff\u00e9renci\u00e9e aux diff\u00e9rentes entr\u00e9es. Comme pr\u00e9sent\u00e9 au d\u00e9but du module, l'une des caract\u00e9ristiques des ordinateurs est d'accepter des donn\u00e9es, il faut pouvoir les consid\u00e9rer dans les traitements effectu\u00e9s.</p> <p>L'id\u00e9e de la clause conditionnelle est d'effectuer une v\u00e9rification sur un bool\u00e9en et d'effectuer un traitement diff\u00e9rent selon la valeur.</p> <pre><code>graph LR\n  A[Code...] --&gt; B{Test logique};\n  B --&gt;|Faux| D[Code...];\n  B --&gt;|Vrai| C[Traitement conditionnel];\n  C --&gt; D;</code></pre>"},{"location":"module1/types_logique_arithmetique/#clause-de-base","title":"Clause de base","text":"<p>Dans le code python, cela prend la forme d'un condition <code>!#py if</code>.</p> <pre><code>Code...\n\nif test_logique :\n    # Traitement conditionnel\n\nCode...\n</code></pre> <p>L'indentation</p> <p>Remarquez l'indentation (retrait de la marge de gauche) suppl\u00e9mentaire sous le <code>!#py if</code> pour la section traitement conditionnel. C'est ce qui permet \u00e0 Python de savoir quelles instructions sont dans le bloc d'instructions conditionnelles (il peut y avoir plusieurs lignes) et quand celui-ci se termine.</p> <p>Il y a trois fa\u00e7ons de construire des tests logiques pour des expressions conditionnelles :</p> <ul> <li>Utiliser une variable bool\u00e9enne;</li> <li>Utiliser un comparateur (on voit \u00e7a \u00e0 la prochaine sous-section); et</li> <li>Utiliser une fonction qui retourne un bool\u00e9en (on voit \u00e7a au prochain module);</li> </ul>"},{"location":"module1/types_logique_arithmetique/#comparateurs","title":"Comparateurs","text":"<p>Les comparateurs, comme leur nom l'indique permettent de comparer deux valeurs ensemble. Il existe 6 comparateurs dont la signification peut varier selon le type de donn\u00e9es.</p> Comparateur Symbole Interpr\u00e9tation des types num\u00e9riques Interpr\u00e9tation du type bool\u00e9en Interpr\u00e9tation des cha\u00eenes de caract\u00e8res \u00c9galit\u00e9 == V\u00e9rifie si c'est exactement la m\u00eame valeur (tr\u00e8s sensible aux erreurs arithm\u00e9tiques des nombres \u00e0 virgule flottante). V\u00e9rifie si les deux bool\u00e9ens ont la m\u00eame valeur. V\u00e9rifie si le contenu des cha\u00eenes est le m\u00eame (sensible \u00e0 la casse). Diff\u00e9rence != V\u00e9rifie si c'est deux valeurs diff\u00e9rentes (tr\u00e8s sensible aux erreurs arithm\u00e9tiques des nombres \u00e0 virgule flottante). V\u00e9rifie si les deux bool\u00e9ens n'ont pas la m\u00eame valeur. V\u00e9rifie si le contenu des cha\u00eenes est le m\u00eame (sensible \u00e0 la casse). Plus petit que &lt; V\u00e9rifie que la valeur d'un est strictement plus petite que l'autre. False est plus petit que True. Compare en ordre lexicographique croissant selon la table ASCII. Plus petit que ou \u00e9gal &lt;= V\u00e9rifie que la valeur d'un est plus petite ou \u00e9gale \u00e0 l'autre. False est plus petit ou \u00e9gal \u00e0 True. Compare en ordre lexicographique croissant selon la table ASCII. Plus grand que &gt; V\u00e9rifie que la valeur d'un est strictement plus grande que l'autre. True est plus grand que False. Compare en ordre lexicographique d\u00e9croissant selon la table ASCII. Plus grand que ou \u00e9gal &gt;= V\u00e9rifie que la valeur d'un est plus grande ou \u00e9gale \u00e0 l'autre. True est plus grand ou \u00e9gal \u00e0 False. Compare en ordre lexicographique d\u00e9croissant selon la table ASCII. <p>Le comportement des comparateurs peut varier sur les autres types de donn\u00e9es.</p> Nombre positif<pre><code>print(\"Saisissez un nombre.\")\nnombre = int(input())\n\nif nombre &gt; 0:\n    print(\"Le nombre est positif.\")\n\nprint(\"Fin du programme\")\n</code></pre>"},{"location":"module1/types_logique_arithmetique/#sinon","title":"Sinon...","text":"<p>Il arrive que l'on veuille forcer le programme entre deux branches d'ex\u00e9cution possibles. </p> <pre><code>graph LR\n  A[Code...] --&gt; B{Test logique};\n  B --&gt; |Vrai| C[Traitement conditionnel];\n  B --&gt; |Faux| E[Traitement alternatif];\n  E --&gt; D[Code...];\n  C --&gt; D;</code></pre> <p>Dans ce cas, on utilise la clause <code>else</code> pour signifier l'autre traitement qui est ex\u00e9cut\u00e9 lorsque la condition est fausse.</p> Nombre positif ou non<pre><code>print(\"Saisissez un nombre.\")\nnombre = int(input())\n\nif nombre &gt; 0:\n    print(\"Le nombre est positif.\")\nelse :\n    print(\"Le nombre n'est pas positif.\")\n\nprint(\"Fin du programme\")\n</code></pre>"},{"location":"module1/types_logique_arithmetique/#et-sinon-encore","title":"Et sinon encore...","text":"<p>Il arrive qu'on puisse avoir plusieurs sc\u00e9narios d'ex\u00e9cution possibles qui sont exclusifs entre eux.</p> <pre><code>graph LR\n  A[Code...] --&gt; B{Test logique};\n  B --&gt; C[Traitement conditionnel];\n  E --&gt; D[Code...];\n  B --&gt; E[Traitement alternatif 1];\n  B --&gt; F[Traitement alternatif 2] --&gt; D;\n  B --&gt; G[Traitement alternatif ...] --&gt; D;\n  C --&gt; D;</code></pre> <p>On utilise dans ce cas les clauses <code>elif</code> (contraction de else if) qui acceptent aussi une condition. Il peut y avoir plusieurs clauses <code>elif</code> qui s'encha\u00eene. La premi\u00e8re clause dont la condition est \u00e9valu\u00e9e \u00e0 vraie est ex\u00e9cut\u00e9e, puis le programme continu. La clause <code>if</code> est toujours la premi\u00e8re et la clause <code>else</code>, lorsqu'elle est n\u00e9cessaire, est toujours la derni\u00e8re.</p> Nombre positif, n\u00e9gatif ou nul<pre><code>print(\"Saisissez un nombre.\")\nnombre = int(input())\n\nif nombre &gt; 0:\n    print(\"Le nombre est positif.\")\nelif nombre &lt; 0 :\n    print(\"Le nombre est n\u00e9gatif.\")\nelse :\n    print(\"Vous avez saisi 0.\");\n\nprint(\"Fin du programme\")\n</code></pre>"},{"location":"module1/types_logique_arithmetique/#operations-logiques","title":"Op\u00e9rations logiques","text":"<p>Les op\u00e9rateurs entre les variables bool\u00e9ennes sont diff\u00e9rents de ceux des variables num\u00e9riques. On trouve les 3 op\u00e9rations suivantes :</p> <ul> <li>Disjonction (ou, <code>or</code>) : op\u00e9rateur binaire faux seulement si les deux op\u00e9randes sont fausses; </li> <li>Conjonction (et,  <code>and</code>) : op\u00e9rateur binaire vrai seulement si les deux op\u00e9randes sont vraies; et</li> <li>N\u00e9gation (non,  <code>not</code>) : op\u00e9ration unaire qui inverse la valeur de l'op\u00e9rande.</li> </ul> <p>On repr\u00e9sente souvent les combinaisons possibles \u00e0 l'aide de tables de v\u00e9rit\u00e9.</p> <p>Table de v\u00e9rit\u00e9 de la disjonction (or)</p> Op\u00e9rande 1 Op\u00e9rande 2 R\u00e9sultat False False False False True True True False True True True True <p>Table de v\u00e9rit\u00e9 de la conjonction (and)</p> Op\u00e9rande 1 Op\u00e9rande 2 R\u00e9sultat False False False False True False True False False True True True"},{"location":"module1/types_logique_arithmetique/#exercice","title":"Exercice","text":"<p>D\u00e9terminez dans quelles conditions un \u00e9l\u00e8ve aura la cote A, B ou C. Quelle cote aura un \u00e9l\u00e8ve avec 2 absences et 85 %, un \u00e9l\u00e8ve avec 4 absences et 90%, et un \u00e9l\u00e8ve avec 0 absence et 59% ?</p> Cote des \u00e9l\u00e8ves<pre><code>if absence &lt; 2 and note &gt; 90 :\n    print(\"Cote A\")\nelif absence &lt; 5 and note &gt; 80 :\n    print(\"Cote B\")\nelif note &gt; 60 :\n    print(\"Cote C\")\nelse :\n    print(\"Cote D\")\n</code></pre>"},{"location":"module1/types_logique_arithmetique/#le-roche-papier-ciseau","title":"Le roche-papier-ciseau","text":"<p>R\u00e9alisez un jeu de roche-papier-ciseau ou deux personnes s'affrontent. Elles doivent chacun choisir un des trois symboles et le programme indique laquelle a gagn\u00e9. Le programme doit permettre de jouer simplement une ronde.</p>"},{"location":"module1/types_logique_arithmetique/#concepts-cles-de-la-section","title":"Concepts cl\u00e9s de la section","text":"<code>bool\u00e9en et op\u00e9rateurs logiques</code> les bool\u00e9ens repr\u00e9sentent une information qui peut prendre deux \u00e9tats vrai ou faux. On peut combiner plusieurs expressions bool\u00e9ennes par les op\u00e9rateurs et et ou. On peut aussi inverser un \u00e9tat avec l'op\u00e9rateur de n\u00e9gation. <code>comparateur</code> v\u00e9rifie une relation entre deux expressions et retourne une valeur bool\u00e9enne selon si la relation est v\u00e9rifi\u00e9e au non. <code>conversion de type</code> permet de changer la repr\u00e9sentation typ\u00e9e d'une donn\u00e9e entre deux types. Elle peut provoquer des erreurs ou des pertes d'information. <code>instruction conditionnelle</code> permet d'ex\u00e9cuter une partie du code seulement lorsqu'une condition est v\u00e9rifi\u00e9e. On peut pr\u00e9ciser des traitements alternatifs si la situation le requiert."},{"location":"module1/types_logique_arithmetique/#les-fonctions-et-les-mots-cles-vus-dans-cette-section","title":"Les fonctions et les mots-cl\u00e9s vus dans cette section","text":"<code>and</code> v\u00e9rifie deux expressions bool\u00e9ennes et retourne un bool\u00e9en vrai seulement si les deux expressions sont vraies. <code>bool</code> permet de convertir une donn\u00e9e vers le type bool\u00e9en. <code>False</code> valeur bool\u00e9enne fausse. <code>float</code> permet de convertir une donn\u00e9e vers une repr\u00e9sentation en virgule flottante. <code>if - elif - else</code> mots-cl\u00e9s pour d\u00e9finir les instructions conditionnelles. <code>int</code> permet de convertir une donn\u00e9e vers une repr\u00e9sentation enti\u00e8re en base 10. <code>str</code> permet de convertir une donn\u00e9e vers une repr\u00e9sentation en cha\u00eene de caract\u00e8res. <code>None</code> repr\u00e9sente l'absence de type de donn\u00e9es. <code>or</code> v\u00e9rifie deux expressions bool\u00e9ennes et retourne un bool\u00e9en vrai seulement d\u00e8s que l'une ou l'autre des expressions est vraie. <code>True</code> valeur bool\u00e9enne vraie."},{"location":"module2/boucles/","title":"Boucles \u00ab\u00a0pour\u00a0\u00bb et \u00ab\u00a0tant que\u00a0\u00bb","text":"<p> Objectifs de la section</p> <p>D\u00e9velopper un algorithme qui inlcut un traitement r\u00e9p\u00e9titif Utiliser les boucles pour et tant que dans les programmes</p> <p> Temps requis</p> <p>40 minutes</p>"},{"location":"module2/boucles/#traitements-repetitifs","title":"Traitements r\u00e9p\u00e9titifs","text":"<p>Le traitement d'ensembles de donn\u00e9es demande souvent d'appliquer un traitement sp\u00e9cifique \u00e0 chaque entr\u00e9e de ce jeu de donn\u00e9es. Plut\u00f4t que de r\u00e9pliquer (copier-coller odieusement) le traitement dans le code, on forme un bloc d'instructions que l'on ex\u00e9cute plusieurs fois, chaque fois sur une entr\u00e9e diff\u00e9rente. Un autre usage fr\u00e9quent des traitements r\u00e9p\u00e9titifs est pour la r\u00e9alisation de m\u00e9thodes de calcul num\u00e9rique; plusieurs m\u00e9thodes sont it\u00e9ratives (\u00e0 chaque \u00e9tape, on converge souvent l\u00e9g\u00e8rement plus vers la solution) ou demandent l'ex\u00e9cution de sommes finies (et encore l\u00e0, plus il y a de termes \u00e0 la somme, meilleurs sont les r\u00e9sultats obtenus). Finalement, simplement pour interagir avec la personne utilisatrice, on utilise aussi souvent des traitements r\u00e9p\u00e9t\u00e9s (recommencer un traitement tant qu'il y a une erreur par exemple).</p>"},{"location":"module2/boucles/#les-structures-de-boucle","title":"Les structures de boucle","text":"<p>On appelle boucle les instructions qui permettent de r\u00e9p\u00e9ter un traitement plusieurs fois. On trouve deux types de boucles :</p> <ol> <li>La boucle tant que (<code>while</code>): s'ex\u00e9cute tant qu'une condition est \u00e9valu\u00e9e \u00e0 vraie. On ne connait pas n\u00e9cessairement le nombre d'it\u00e9rations de la boucle;</li> <li>La boucle pour (<code>for</code>) :  s'ex\u00e9cute pour un nombre d\u00e9termin\u00e9 d'it\u00e9rations.</li> </ol> <p>Dans les deux cas, il est important dans l'\u00e9criture du programme de s'assurer que les boucles s'arr\u00eatent \u00e0 un moment donn\u00e9 (que la condition d'arr\u00eat est atteinte), autrement le programme ex\u00e9cutera toujours le m\u00eame bloc d'instruction et sera pris \u00e0 cet endroit.</p>"},{"location":"module2/boucles/#la-boucle-while","title":"La boucle <code>while</code>","text":"<p>La syntaxe de la boucle <code>while</code> est la suivante :</p> Structure de la boucle while<pre><code>while condition_logique : \n    # Instructions dans la boucle\n    # Instructions dans la boucle\n\n# Instructions apr\u00e8s la boucle\n</code></pre> <p>Indentation dans les boucles</p> <p>Comme pour les instructions conditionnelles, l'indentation devant les instructions apr\u00e8s la d\u00e9claration de la boucle indique quelles instructions doivent \u00eatre r\u00e9p\u00e9t\u00e9es.    </p> <p>Par exemple, on souhaite qu'une personne saisisse un nombre positif \u00e0 la console. On lui demande donc un nombre tant que celui-ci ne satisfait pas la contrainte.</p> Sch\u00e9ma d'ex\u00e9cutionCode <p> Sch\u00e9ma d'ex\u00e9cution - Saisir un nombre positif Saisir un nombre positif<pre><code>print(\"Veuillez saisir un nombre positif.\")\nnombre = int(input())\n\nwhile nombre &lt;= 0:\n    print(\"C'est pas bien compliqu\u00e9, entrez n'importe quel nombre plus grand que 0 !\")\n    nombre = int(input())\n\nprint(\"Hourra ! Tu as saisi \" + str(nombre) + \" .\")\n</code></pre> <p>Inversion de la condition</p> <p>Plusieurs auraient une tendance naturelle \u00e0 utiliser <code>nombre &gt; 0</code> comme condition dans le <code>while</code>, mais on veut \u00e9crire le code de fa\u00e7on \u00e0 ce que la v\u00e9rification de la condition (test logique retourne vrai), entra\u00eene l'ex\u00e9cution du code, d'o\u00f9 pourquoi on \u00ab\u00a0inverse\u00a0\u00bb la fa\u00e7on de penser le probl\u00e8me. C'est ce que l'on appelle une clause de garde : sa v\u00e9rification emp\u00eache le programme de poursuivre tant que les donn\u00e9es ne sont pas valides. Elle est la gardienne de l'int\u00e9grit\u00e9 du programme. </p>"},{"location":"module2/boucles/#la-boucle-for","title":"La boucle <code>for</code>","text":"<p>La syntaxe de la boucle <code>for</code> est un peu plus complexe, car il faut d\u00e9finir un compteur pour d\u00e9terminer le nombre d'it\u00e9rations \u00e0 faire. Cette boucle se compose de 4 morceaux (au lieu d'une unique condition dans le cas de la boucle <code>while</code>). </p> <ul> <li>Un compteur de la boucle</li> <li>L'initialisation du compteur (souvent 0, mais on peut utiliser une autre valeur si le probl\u00e8me le justifie);</li> <li>La valeur limite du compteur (la boucle s'arr\u00eate lorsque le compteur atteint cette valeur). La comparaison entre la valeur du compteur et la valeur limite est stricte (&lt; ou &gt;); et </li> <li>Le pas du compteur (la valeur dont le compteur est incr\u00e9ment\u00e9 \u00e0 chaque it\u00e9ration de la boucle, souvent cette valeur est 1).</li> </ul> Structure de la boucle for<pre><code>for compteur in range(init, limite, pas) : \n    # Instructions dans la boucle\n    # Instructions dans la boucle\n\n# Instructions apr\u00e8s la boucle\n</code></pre> <p>La variable compteur (qu'on appelle souvent simplement i) d\u00e9clar\u00e9e dans la boucle contient la valeur courante du compteur. Voici quelques exemples de boucles <code>for</code> :</p> Afficher les nombres de 1 \u00e0 10Afficher les nombres impairs entre 5 et 17Afficher les nombres entre -5 et 5 en ordre d\u00e9croissant Les entiers de 1 \u00e0 10<pre><code>for i in range(1, 11, 1):\n    print(i)\n\n## Pour afficher 10, il faut arr\u00eater \u00e0 11, car l'instruction print s'ex\u00e9cute seulement pour les valeurs strictement plus petites que 11\n</code></pre> Les entiers impairs de 5 \u00e0 17<pre><code>for i in range(5, 18, 2):\n    print(i)\n</code></pre> Les entiers entre -5 et 5 en ordre d\u00e9croissant<pre><code>for i in range(5, -6, -1):\n    print(i)\n</code></pre>"},{"location":"module2/boucles/#raccourcis-decriture-de-la-fonction-range","title":"Raccourcis d'\u00e9criture de la fonction <code>range</code>","text":"<p>La fonction <code>py range</code> d\u00e9finie certains de ses param\u00e8tres par d\u00e9faut, ce qui signifie que si l'on omet des param\u00e8tres, alors Python lui assigne automatiquement une valeur. </p> Fonction <code>range</code>avec 2 param\u00e8tresFonction <code>range</code>avec 1 param\u00e8tre <p>Par d\u00e9faut, le pas vaut 1. Les deux appels ci-dessous sont \u00e9quivalents.</p> Valeur du pas par d\u00e9faut<pre><code>for i in range(0, 10, 1):\n    # Instructions dans la boucle\n\nfor i in range(0, 10):\n    # Instructions dans la boucle\n</code></pre> <p>Par d\u00e9faut, le pas vaut 1 et l'initialisation du compteur se fait \u00e0 0. Les deux appels ci-dessous sont \u00e9quivalents.</p> Valeur du pas par d\u00e9faut<pre><code>for i in range(0, 10, 1):\n    # Instructions dans la boucle\n\nfor i in range(10):\n    # Instructions dans la boucle\n</code></pre>"},{"location":"module2/boucles/#lerreur-arithmetique-du-float","title":"L'erreur arithm\u00e9tique du float","text":"<p>Avec une boucle, additionnez 100 fois la valeur 1 / 100. Que remarquez-vous ?</p> Solution Addition avec errreur arithm\u00e9tique<pre><code>somme = 0.0\n\nfor i in range(100):\n    somme = somme + (1.0/100.0)\n\nprint(str(somme))\n</code></pre> <p>La somme est de 1.0000000000000007, ce qui t\u00e9moigne de l'accumulation d'une erreur arithm\u00e9tique. </p>"},{"location":"module2/boucles/#exercices-avec-les-boucles","title":"Exercices avec les boucles","text":"<ol> <li>Calculez la somme des multiples de 3 entre 5 et 20 (r\u00e9ponse 75).</li> <li>Affichez les 250 premiers termes de la suite de Fibonacci.</li> </ol> <p>$$ F_{n+2} = F_{n+1} + F_{n}\\text{, avec } F_0 = 1\\text{ et } F_1 = 1 $$</p> <ol> <li> <p>Exercice du roche-papier-ciseau, partie 2 : modifiez votre code du roche-papier-ciseau pour permettre aux joueurs de recommencer aussi longtemps qu'il y a une \u00e9galit\u00e9. </p> </li> <li> <p>Affichez la forme suivante :</p> <pre><code>*\n**\n***\n****\n*****\n</code></pre> </li> <li> <p>Affichez la forme suivante :</p> <pre><code>*****\n****\n***\n** \n*\n</code></pre> </li> <li> <p>Affichez la forme suivante :</p> <pre><code>*****\n ****\n  ***\n   ** \n    *\n</code></pre> </li> </ol>"},{"location":"module2/boucles/#concepts-cles-de-la-section","title":"Concepts cl\u00e9s de la section","text":""},{"location":"module2/boucles/#les-fonctions-et-les-mots-cles-vus-dans-cette-section","title":"Les fonctions et les mots-cl\u00e9s vus dans cette section","text":""},{"location":"module2/collections/","title":"Collections de donn\u00e9es","text":"<p> Objectifs de la section</p> <p>Reconna\u00eetre les situations d'utilisation des diff\u00e9rentes collections de donn\u00e9es  Utiliser les collections de donn\u00e9es : listes, n-uplet, ensembles et dictionnaires</p> <p> Temps requis</p> <p>45 minutes</p>"},{"location":"module2/collections/#utilite-des-collections-de-donnees","title":"Utilit\u00e9 des collections de donn\u00e9es","text":""},{"location":"module2/collections/#caracterisques-de-collections-de-donnees","title":"Caract\u00e9risques de collections de donn\u00e9es","text":""},{"location":"module2/collections/#liste","title":"Liste","text":""},{"location":"module2/collections/#n-uplet","title":"N-uplet","text":""},{"location":"module2/collections/#ensemble","title":"Ensemble","text":""},{"location":"module2/collections/#dictionnaire","title":"Dictionnaire","text":""},{"location":"module2/documenter_planifier/","title":"Planifier la programmation et documenter le code","text":"<p> Objectifs de la section</p> <p>Planifier ad\u00e9quatement la programmation \u00e0 r\u00e9aliser  Documenter le code selon les standards du PEP257</p> <p> Temps requis</p> <p>20 minutes</p>"},{"location":"module2/documenter_planifier/#planifier-la-programmation","title":"Planifier la programmation","text":"<p>Le cycle de d\u00e9veloppement en cascade (m\u00e9thode traditionnelle) des logiciels est le suivant :</p> <p></p> <p>Pour effectuer la planfication (\u00e9tapes d'analyse et de conception), il est sugg\u00e9r\u00e9 d'utiliser le gabarit suivant :</p> <p> Gabarit de planification de la programmation</p> <p> Gabarit de planification de la programmation (avec consignes)</p>"},{"location":"module2/documenter_planifier/#documenter-le-code","title":"Documenter le code","text":"<p>Plus le code augmente en taille, plus il est important de laisser des traces des r\u00e9flexions et de l'utilit\u00e9 du code. C'est ce que l'on appelle la documentation. L'utilisation de la documentation permet de lire en texte ce qu'une fonction fait sans constamment devoir en relire le code. Elle aide aussi \u00e0 reconna\u00eetre l'intention derri\u00e8re une fonction ou les astuces utilis\u00e9es pour contourner certains probl\u00e8mes.</p>"},{"location":"module2/documenter_planifier/#commentaires-de-code","title":"Commentaires de code","text":"<p>Les commentaires dans le code prennent la forme d'une simple phrase plac\u00e9 apr\u00e8s le caract\u00e8re <code>#</code>. On peut diviser le commentaire sur plusieurs lignes en r\u00e9p\u00e9tant le symbole <code>#</code> au d\u00e9but de chaque ligne. Il n'est pas n\u00e9cessaire de commenter chaque ligne (en fait m\u00eame \u00e7a n'apporte rien et allourdit la lecture). On r\u00e9serve les commentaires pour les lignes plus complexes ou celles qui introduisent un bloc de code (par exemple, un boucle qui aurait 3 instructions \u00e0 l'int\u00e9rieur pourrait avoir un commentaire qui la pr\u00e9c\u00e8de.)</p>"},{"location":"module2/documenter_planifier/#docstring","title":"Docstring","text":"<p>Les docstring sont des commentaires qui expliquent ce qu'une fonction fait. Elles consistent en plusieurs lignes d\u00e9limit\u00e9es par 3 guillemets anglais. Aucun retour \u00e0 la ligne n'est fait avant ou apr\u00e8s la docstring.</p> Exemple de documentation d'une fonction<pre><code>    def aire_rectangle(base, hauteur = 1.0):\n        \"\"\"Calcul l'aire d'un rectangle et la retourne.\n\n        Keywords arguments:\n        base -- la base du rectangle\n        hauteur -- la hauteur du rectangle (default = 0.0)\n        \"\"\"\n        return base * hauteur\n</code></pre> <p>Expressions anglaises</p> <p>Il est important d'utiliser l'expression anglaise \u00ab\u00a0Keywords arguments:\u00a0\u00bb et \u00ab\u00a0default\u00a0\u00bb pour introduire les param\u00e8tres de la fonction et les valeurs par d\u00e9faut, car certains traitements peuvent utiliser les docstrings et utiliseront cette expression.</p>"},{"location":"module2/documenter_planifier/#exercice-premier-programme-complet","title":"Exercice - premier programme complet","text":"<p>Planifiez et programmez une calculatrice simple. La calculatrice doit permettre d'additionner, de soustraire, de multiplier et de diviser des nombres. Chaque fois qu'un calcul est effectu\u00e9, la r\u00e9ponse est affich\u00e9e \u00e0 la personne utilisatrice. Tant que la personne utilisatrice ne demande pas de quitter, la calculatrice doit demander un nouveau calcul.</p>"},{"location":"module2/fonctions/","title":"Les fonctions","text":"<p> Objectifs de la section</p> <p>\u00c9crire une fonction avec des param\u00e8tres et des valeurs de retour  Appeler une fonction</p> <p> Temps requis</p> <p>30 minutes</p>"},{"location":"module2/fonctions/#quest-ce-quune-fonction","title":"Qu'est-ce qu'une fonction ?","text":"<p>Les fonctions, d'un point de vue des math\u00e9matiques, sont des op\u00e9rateurs complexes qui acceptent une ou plusieurs variables et retourne une ou plusieurs valeurs. Une fonction math\u00e9matique a comme seule contrainte que pour les m\u00eames valeurs accept\u00e9es, le m\u00eame r\u00e9sultat est retourn\u00e9 (autrement dit chaque valeur du domaine est associ\u00e9e \u00e0 une seule valeur de l'image de la fonction). On peut penser aux fonctions polynomiales ou trigonom\u00e9triques classiques (\\(f(x) = x\\), \\(f(x) = 5\\) ou \\(f(x, y) = x+y\\)).</p> <p>En informatique, le terme fonction d\u00e9signe une id\u00e9e similaire : soit le fait de prendre des valeurs et d'appliquer des op\u00e9rations sur ces valeurs. Les fonctions sont des blocs de code qui encapsulent un traitement. Ces blocs de code acceptent aucune, une ou plusieurs variable et retourne aucun ou un seul r\u00e9sultat. Dans le code, on retrouve une instruction qui vise \u00e0 d\u00e9clarer (declare) une fonction et une instruction qui vise \u00e0 appeler ou invoquer (call ou invoke) la fonction.</p> Mod\u00e8le de la fonction multiplierEx\u00e9cution de la fonction multiplier <p> </p> <p> </p>"},{"location":"module2/fonctions/#declarer-une-fonction","title":"D\u00e9clarer une fonction","text":"<p>Le mot-cl\u00e9 <code>def</code> est utilis\u00e9 pour d\u00e9clarer un fonction. On indique le nom de la fonction (m\u00e8me r\u00e8gles d'indicateur que pour les variables). On place ensuite entre parenth\u00e8ses les param\u00e8tres de la fonction. Si la fonction n'a pas de param\u00e8tres, on place une paire de parenth\u00e8ses vides. On place ensuite un deux-points puis tout le code de la fonction sera ident\u00e9 d'un niveau.</p> Structure de base d'une fonction<pre><code># Fonction sans param\u00e8tre\n\ndef identificateur_fonction():\n    # Instructions dans la fonction\n\n# Appel de la fonction\nidentificateur_fonction()\n</code></pre>"},{"location":"module2/fonctions/#retourner-des-valeurs","title":"Retourner des valeurs","text":"<p>Il est possible de retourner une valeur \u00e0 la fin de l'ex\u00e9cution d'une fonction. Pour se faire, on utilise l'instruction <code>return</code>. D\u00e8s que cette instruction est rencontr\u00e9e, l'ex\u00e9cution de la fonction s'arr\u00eate et la valeur est retourn\u00e9e. Il est possible de mettre plusieurs instructions <code>return</code> dans une fonction. Dans ce cas, la premi\u00e8re instruction <code>return</code> ex\u00e9cut\u00e9e met fin \u00e0 l'ex\u00e9cution de la fonction.</p> La fonction multiplier<pre><code>def identificateur_fonction(operande_gauche, operande_droite):\n    return operande_gauche * operande_droite\n</code></pre> La fonction calcul_taxes<pre><code>def calcul_taxes(montant, taxable_provincial, taxable_federal):\n    if taxable_provincial == True and taxable_federal == True:\n        return montant * 1.14975\n    elif taxable_provincial == False and taxable_federal == False:\n        return montant\n    elif taxable_provincial == True:\n        return montant * 1.0975\n    else:\n        return montant * 1.05 \n</code></pre>"},{"location":"module2/fonctions/#portee-des-variables","title":"Port\u00e9e des variables","text":"<p>Les variables d\u00e9clar\u00e9es dans les fonction et les param\u00e8tres ont une port\u00e9e scope limit\u00e9e \u00e0 la fonction qui les d\u00e9clare. Autrement dit, les variables et les param\u00e8tres suivent ces deux comportements :</p> <ul> <li>On peut r\u00e9utiliser les identificateurs utilis\u00e9s ailleurs sans risque d'effet de bord (que la modification d'une ait un impact sur l'autre); et</li> <li>On ne peut pas utiliser les valeurs des param\u00e8tres et variables d\u00e9clar\u00e9es dans la fonction hors de celle-ci.</li> </ul> <p>Voici quelques exemples des cons\u00e9quences de la port\u00e9e des variables et des param\u00e8tres.</p> Port\u00e9e des variables et des param\u00e8tres<pre><code>    ###### Exemple 1 ######\n    def aire_rectangle(base, hauteur):\n        aire = base * hauteur\n        return aire\n\n    def aire_triangle(base, hauteur):\n        aire = base * hauteur * 0.5\n        return aire\n\n    # Tout \u00e0 fait correct, les variables base et hauteur sont li\u00e9s chacune \u00e0 une fonction diff\u00e9rente.\n\n    ###### Exemple 2 ######\n    rayon = 3\n    aire = 55\n\n    def aire_cercle(rayon):\n        aire = 3.1415926536 * rayon\n        return aire\n\n    print(aire_cercle(6))          # Retourne environ 18.85\n    print(aire_cercle(rayon))      # Retourne environ 9.42\n    print(str(aire))               # Affiche 55\n</code></pre> <p>Dans cet exemple, il peut sembler y avoir plusieurs variables qui s'appellent <code>aire</code>, <code>base</code> ou <code>hauteur</code> mais comme elles sont d\u00e9clar\u00e9es dans diff\u00e9rentes fonctions, elle n'interf\u00e8rent pas entre elles.</p> <p>Ordre de d\u00e9claration des fonctions</p> <p>Les fonctions doivent \u00eatre d\u00e9clar\u00e9es avant d'\u00eatre utilis\u00e9es. C'est pourquoi on place toujours la les lignes suivantes \u00e0 la fin du fichier.</p> <pre><code>if __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"module2/fonctions/#allez-plus-loin-avec-les-fonctions","title":"Allez plus loin avec les fonctions","text":""},{"location":"module2/fonctions/#valeurs-par-defaut","title":"Valeurs par d\u00e9faut","text":"<p>Il est possible d\u00e9finir des valeurs par d\u00e9faut \u00e0 des param\u00e8tres de la fonction. Les valeurs par d\u00e9faut font en sorte qu'il n'est pas n\u00e9cessaire d'indiquer le param\u00e8tre lors de l'appel. Pour indiquer une valeur par d\u00e9faut, on ajoute un symbole d'\u00e9galit\u00e9 apr\u00e8s le param\u00e8tre suivi de la valeur d\u00e9faut. Par exemple, voici une d\u00e9finition de la fonction <code>calcul_taxes</code> avec des valeurs par d\u00e9faut.</p> Fonction calcul_taxes avec des param\u00e8tres par d\u00e9faut<pre><code>def calcul_taxes(montant, taxable_provincial = True, taxable_federal = True):\n   # Instructions de la fonction\n</code></pre> <p>Donc par d\u00e9faut, on applique les deux taxes sur les deux produits. La difficult\u00e9 avec les valeurs par d\u00e9faut est que d\u00e8s qu'on utilise une valeur par d\u00e9faut, tous les param\u00e8tres d\u00e9finis apr\u00e8s doivent aussi proposer une valeur par d\u00e9faut. Par exemple, le code suivant est fautif.</p> <p>Erreur dans la d\u00e9claration des param\u00e8tres</p> Fonction calcul_taxes avec des param\u00e8tres par d\u00e9faut<pre><code>def calcul_taxes(montant, taxable_provincial = True, taxable_federal):\n    # Instructions de la fonction\n</code></pre> <p>Affiche le message suivant : SyntaxError: non-default argument follows default argument</p> <p>Regardons quelques appels de la fonction <code>calcul_taxes</code></p> Appels de la fonction calcul_taxes avec des param\u00e8tres par d\u00e9faut<pre><code>def calcul_taxes(montant, taxable_provincial = True, taxable_federal = True):\n   # Instructions de la fonction\n\ncalcul_taxes(10.0)              # \u00c9quivalent \u00e0 calcul_taxes(10.0, True, True)\ncalcul_taxes(10.0, False)       # \u00c9quivalent \u00e0 calcul_taxes(10.0, False, True)\n</code></pre> <p>Comment appeler la fonction pour appliquer seulement la taxe f\u00e9d\u00e9rale ? Il faut indiquer tous les param\u00e8tres dans l'ordre, donc il faudra aussi indiquer la taxe provinciale. Il existe une seconde m\u00e9thode d\u00e9taill\u00e9e \u00e0 la section ci-dessous. </p>"},{"location":"module2/fonctions/#indiquer-explicitement-les-parametres-lors-de-lappel","title":"Indiquer explicitement les param\u00e8tres lors de l'appel","text":"<p>Normalement, on appelle la fonction avec les param\u00e8tres dans le m\u00eame ordre que lors de la d\u00e9claration. On peut changer cet ordre en indiquant le nom des param\u00e8tres lors de l'appel. Cette technique permet de contourner le probl\u00e8me rencontr\u00e9 lorsqu'on veut utiliser que certaines des valeurs par d\u00e9faut. Pour indiquer explicitement les param\u00e8tres lors de l'appel, on indique dans les parenth\u00e8ses lors de l'appel le nom du param\u00e8tre suivi d'un symbole d'\u00e9galit\u00e9 et de sa valeur.</p> Appels de la fonction calcul_taxes avec des param\u00e8tres par d\u00e9faut<pre><code>def calcul_taxes(montant, taxable_provincial = True, taxable_federal = True):\n   # Instructions de la fonction\n\ncalcul_taxes(montant = 10.0)                                    # \u00c9quivalent \u00e0 calcul_taxes(10.0, True, True)\ncalcul_taxes(montant = 10.0, taxable_provincial = False)        # \u00c9quivalent \u00e0 calcul_taxes(10.0, False, True)\ncalcul_taxes(montant = 10.0, taxable_federal = False)           # \u00c9quivalent \u00e0 calcul_taxes(10.0, True, False) \ud83d\udc4d\ncalcul_taxes(10.0, taxable_provincial = False)                  # \u00c9quivalent \u00e0 calcul_taxes(10.0, False, True)\ncalcul_taxes(montant = 10.0, False)                             # Provoque une erreur \ud83d\ude22 || SyntaxError: positional argument follows keyword argument\n</code></pre> <p>Par contre, d\u00e8s qu'un param\u00e8tre est indiqu\u00e9 explicitement avec son nom, tous les param\u00e8tres apr\u00e8s doivent aussi \u00eatre indiqu\u00e9s explicitement avec leur nom.</p>"},{"location":"module2/fonctions/#exercices-sur-les-fonctions","title":"Exercices sur les fonctions","text":"<ol> <li>Exercice du roche-papier-ciseau, partie 3 : organisez le code du roche-papier-ciseau en fonction. Chacune des fonctions doit avoir une responsabilit\u00e9. Suggestion : vous devriez avoir 3 fonctions (la fonction main et deux autres).</li> <li>Pour trouver les z\u00e9ros d'une fonction, on peut utiliser la m\u00e9thode de Newton. Il s'agit de construire une suite de points convergents (ou du moins ils convergent g\u00e9n\u00e9ralement ) vers l'un des z\u00e9ros de la fonction. \u00c0 l'aide de la m\u00e9thode de Newton, trouvez le z\u00e9ro r\u00e9el, avec 4 d\u00e9cimales de pr\u00e9cision, de la fonction \\(f(x) = x^3-3x^2+4x-4\\) dont la d\u00e9riv\u00e9e est \\(f'(x) = 3x^2-6x+4\\) (r\u00e9ponse 2). Les termes it\u00e9r\u00e9s de la m\u00e9thode de Newton prennent la forme suivante :</li> </ol> <p>$$ x_{n+1} = x_n - f(x_n)/f'(x_n) $$</p>"}]}