{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Simulations en astrophysique","text":"<p>Le cours de Simulations en astrophysique qui s'inscrit en option dans la quatri\u00e8re session de Sciences de la nature vise \u00e0 initier les personnes \u00e9tudiantes aux \u00e9l\u00e9ments suivants :</p> <ul> <li>Les concepts d'astrophysiques intervenant dans la gravitation de corps c\u00e9lestes; </li> <li>Les algorithmes num\u00e9riques de r\u00e9solution d'\u00e9quation; et</li> <li>L'utilisation d'un moteur de jeu vid\u00e9o pour produire des simultations.</li> </ul> <p>Le pr\u00e9sent site de notes de cours s'int\u00e9resse \u00e0 l'aspect informatique en pr\u00e9sentant notamment : </p> <ul> <li>La structure et les repr\u00e9sentations de mod\u00e8les 3D;</li> <li>L'ajout d'objets dans l'interface de la simulation ou du jeu;</li> <li>La r\u00e9solution de probl\u00e8mes de fa\u00e7on num\u00e9rique.</li> </ul>"},{"location":"#droits-et-distribution","title":"Droits et distribution","text":"<p>Tout le mat\u00e9riel de ce site (sauf mention contraire) est sous licence Creative Commons 4.0 avec obligation d'attribution, interdiction de r\u00e9utilisation \u00e0 des fins commerciales et partage dans les m\u00eames conditions.</p> <p>   Alexandre Ouellet | 2026</p>"},{"location":"algo/methode_euler/","title":"M\u00e9thode d'Euler explicite","text":"<p> Contenus de la page</p> <p>Algorithmes de calcul num\u00e9rique</p> <p> Temps requis</p> <p>30 minutes</p> <p>La m\u00e9thode d'Euler est un algorithme num\u00e9rique qui permet d'approximer le r\u00e9sultats d'une \u00e9quation diff\u00e9rentielle de premier ordre (qui ne fait intervenir que la d\u00e9riv\u00e9e premi\u00e8re). Comme on est en pr\u00e9sence d'une \u00e9quation diff\u00e9rentielle, on ne peut pas toujours conna\u00eetre la fonction initiale. Toutefois, l'id\u00e9e de la m\u00e9thode est d'utiliser le fait que la valeur de la d\u00e9riv\u00e9e peut servir \u00e0 approximer la valeur de la fonction localement.</p> <p>Le schm\u00e9ma d'Euler explicite est le suivant : pour une \u00e9quation diff\u00e9rentielle \\(y'(x) = c(x)y(x)\\) avec \\(c(x) et y(x)\\) continue et diff\u00e9rentiable sur un intervalle \\([a, b]\\) et une condition initiale \\(y(a) = y_0\\) connue, alors pour un pas \\(h\\) fix\u00e9, la suite suivante converge vers \\(y(b)\\).</p> \\[ y_{i+1} = y_{i} + h \\times y'_{i} \\approx y_{i} + h \\times c(x_i)y_i, \\text{ avec } x_i = a + ih  \\] Approximation par la m\u00e9thode d'Euler. Tir\u00e9 de Illustration of the Euler Mehode <p>La suite des points \\(A_i\\) correspond aux \\(y_i\\) qui seront calcul\u00e9s.</p>"},{"location":"algo/methode_euler/#exemple-1","title":"Exemple 1","text":"<p>Par exemple, on souhaite calculer la valeur de \\(y(1)\\). On ne connait pas \\(y\\), mais on sait que \\(y'(x) = 2y(x)\\) et que \\(y(0) = 1\\). On utilise un pas \\(h\\) de \\(0.5\\).</p> <p>\u00c9tape 1 : poser les valeurs connues</p> <ul> <li>\\(y_0\\) = 1</li> <li>\\(h\\) = 0.5 (2 \u00e9tapes de calcul)</li> <li>\\(y'_i = 2y_i\\)</li> </ul> <p>\u00c9tape 2 : effectuer le calcul</p> \\[ \\begin{align*} y_1 &amp;= y_0 + h \\times y'_0 \\\\\\\\ &amp;= 1 + 0.5 \\times 2y_0 \\\\\\\\ &amp;= 1 + 0.5 \\times 2 \\times 1 \\\\\\\\ &amp;= 2 \\end{align*} \\] \\[ \\begin{align*} y_2 &amp;= y_0 + h \\times y'_1 \\\\\\\\ &amp;= 1 + 0.5 \\times 2y_1 \\\\\\\\ &amp;= 2 + 0.5 \\times 2 \\times 2 \\\\\\\\ &amp;= 4 \\end{align*} \\] <p>\u00c9tape 3 : solution </p> <p>Donc \\(y(1) \\approx 4\\). </p> <p>La valeur r\u00e9elle est 7,39, mais comme un tr\u00e8s grand pas est utilis\u00e9, il est normal d'avoir une erreur importante. La fonction ici \u00e9tait \\(y(x) = 2e^{x}\\). </p>"},{"location":"algo/methode_euler/#exercice-1","title":"Exercice 1","text":"<p>Appliquez la m\u00e9thode d'Euler avec l'\u00e9quation suivante \\(y'(x) = \\frac{y(x)}{2}\\) et \\(y(0) = 2\\). Approximez la valeur de \\(y(0.6)\\) avec un pas \\(h\\) de \\(0.2\\)</p> Solution \\[ \\begin{align*}     y_0 &amp;= 2 \\\\\\\\     y_1 &amp;= 2 + 0.2 \\times \\frac{2}{2} = 2.2 \\\\\\\\     y_2 &amp;= 2.2 + 0.2 \\times \\frac{2.2}{2} = 2.42 \\\\\\\\     y_3 &amp;= 2.42 + 0.2 \\times \\frac{2.42}{2} = 2.662 \\end{align*} \\] <p>Donc \\(y(0.6) = 2.662\\). </p> <p>La valeur r\u00e9elle est 2.35, la fonction est \\(y(x) = e^{\\frac{x}{2}}+1\\)</p>"},{"location":"algo/methode_euler/#en-code","title":"En code","text":"<p>La m\u00e9thode d'Euler peut \u00eatre impl\u00e9ment\u00e9e de la fa\u00e7on suivante pour le probl\u00e8me pr\u00e9c\u00e9dent.</p> Calcul de la m\u00e9thode d'Euler<pre><code>def euler(a, b, nb_etapes):\n    y_i = 2                             \n    h = (b-a)/nb_etapes\n\n    for i in range(nb_etapes):\n        y_i = y_i + h * (0.5 * y_i)\n\n    return y_i\n\nprint(euler(0, 0.6, 3))\n</code></pre> <p>La variable <code>y_i</code> prend les diff\u00e9rentes valeurs d'approximation. On l'initialise \u00e0 2 \u00e0 cause de la condition initiale du probl\u00e8me. On calcule ensuite le pas avec le nombre d'\u00e9tapes et l'intervalle. Ensuite, on boucle pour le nombre d'\u00e9tapes d\u00e9termin\u00e9es.</p> <p>La ligne 6 repr\u00e9sente la formule de la m\u00e9thode d'Euler. \u00c0 droite du \u00e9gal, on a le calcul de la prochaine \u00e9tape. Comme un ordinateur travaille de fa\u00e7on s\u00e9quentielle, toute la partie de droite est calcul\u00e9e avant l'affectation. On voit donc l'usage de la valeur pr\u00e9c\u00e9dente et du pas. On a remplac\u00e9 la pente de la d\u00e9riv\u00e9e de l'\u00e9tape pr\u00e9c\u00e9dente par son approximation (<code>0.5 * y_i</code>) d\u00fb \u00e0 l'\u00e9quation diff\u00e9rentielle donn\u00e9e.</p>"},{"location":"algo/methode_euler/#exercices","title":"Exercices","text":"<ol> <li>Modifiez le programme pr\u00e9c\u00e9dent pour r\u00e9soudre le probl\u00e8me suivant : \\(y'(x) = 4y(x) + 2\\) avec \\(y(0) = 2\\) comme condition initiale. Trouvez la valeur de \\(y(1)\\) avec un pas de 0.01.</li> </ol> Solution <p>24.7525</p> <ol> <li>R\u00e9solver le probl\u00e8me  \\(y'(x) = x \\times y(x)\\) avec \\(y(0) = 1\\) comme condition initiale. Trouvez la valeur de \\(y(1)\\) avec un pas de 0.01.</li> </ol> Solution <p>1.6378</p> <ol> <li>Soit un objet dont la vitesse varie dans le temps. La vitesse (m/s) est \u00e9gale au produit du cosinus du temps \u00e9coul\u00e9 par la position. L'\u00e9quation r\u00e9gissant la vitesse <code>v</code> en fonction de la position <code>p</code> est :</li> </ol> \\[ v = cos(t)p(t) \\Leftarrow p'(t) = cos(t)p(t) \\] <p>Sachant que l'objet est initialement \u00e0 la position 5 en \\(t=0\\) (soit \\(p(0) = 5\\)), trouvez quelle sera sa position \u00e0 t = 2 avec un pas de 0.01. </p> Solution <p>12.4504</p>"},{"location":"algo/methodes_numeriques/","title":"M\u00e9thodes num\u00e9riques","text":"<p> Contenus de la page</p> <p>Algorithmes de calcul num\u00e9rique</p> <p> Temps requis</p> <p>60 minutes</p> <p>L'informatique permet d'effectuer une multitude de calculs et de simultations num\u00e9riques qui donne une solution appel\u00e9e num\u00e9rique. \u00c0 la diff\u00e9rence des solutions analytiques, les solutions num\u00e9riques sont souvent des approximations avec une erreur (que l'on peut rendre aussi petite que souhait\u00e9e), mais permettent d'approximer tous les probl\u00e8mes calculables (oui, il existe des fonctions non calculables...). Les solutions analytiques elles sont exactes, mais demandent beaucoup de travail humain pour \u00eatre calcul\u00e9es. Dans de nombreuses circonstances, on peut traduire un probl\u00e8me sous forme d'algorithme et y trouver une solution num\u00e9rique, sans pour autant \u00eatre en mesure de le r\u00e9soudre analytiquement.</p> <p>Habituellement les algorithmes num\u00e9riques donnent une suite \\({x_n}\\) de points qui convergent (s'approche) vers une limite donn\u00e9e, pour des \\(n\\) suffisamment grands. Vous avez s\u00fbrement \u00e9tudi\u00e9 ce concept de limite et convergence dans les cours de calcul diff\u00e9rentiel et int\u00e9gral.</p>"},{"location":"algo/methodes_numeriques/#la-convergence-numerique-et-analytique","title":"La convergence num\u00e9rique et analytique","text":"<p>La convergence d'une suite de points \\({x_n}\\) vers une limite \\(L\\) permet d'obtenir le r\u00e9sultat d'une m\u00e9thode de calcul num\u00e9rique. Nous verrons l'effet des \u00e9tapes de calcul dans les prochaines sections. Prenons l'exemple de calculer la valeur de \\(\\pi\\). On peut utiliser la suite de Madhava-Leibniz pour y arriver.</p> \\[  \\frac{\\pi}{4} = \\sum_{k=0}^{\\infty}\\frac{(-1)^k}{2x+1} = 1 - \\frac{1}{3} + \\frac{1}{5} - \\frac{1}{7} + \\frac{1}{9} + \\cdots \\] <p>Pas super efficace</p> <p>Cette m\u00e9thode n'est pas tr\u00e8s efficace, mais est simple \u00e0 comprendre. Pour une m\u00e9thode plus efficace, vous pouvez utiliser la formule de Ramanujan</p> <p>Voici la valeur calculer pour diff\u00e9rentes valeurs de k</p> <p> k Approximation de \\(\\pi\\) 0 4.000000 1 2.666666 2 3.466666 5 2.976046 10 3.232316 100 3.151493 1 000 3.142592 2 500 3.141992 10 000 3.141693 100 000 3.141603 1 000 000 3.141594 <p></p> <p>Donc dans cet exemple, on peut voir que les d\u00e9cimales de \\(\\pi\\) sont de plus en plus pr\u00e9cises selon la valeur de \\(k\\).</p> <p>Suite de Cauchy</p> <p>Une suite est dite de Cauchy s'il existe une valeur \u00e0 partir de laquelle la diff\u00e9rence en valeur absolue entre deux termes cons\u00e9cutifs forme une suite strictement d\u00e9croissante.</p> <p>D'un point de vue analytique, \u00eatre de Cauchy est n\u00e9cessaire, mais non suffisant pour conclure \u00e0 une convergence. Dans le cas num\u00e9rique, d\u00e8s qu'une suite est de Cauchy, nous risquons d'observer ou de conclure \u00e0 un r\u00e9sultat de convergence num\u00e9rique. Cependant, il faut rester prudent, car \u00eatre de Cauchy n'indique pas que la suite est convergente.</p>"},{"location":"algo/methodes_numeriques/#les-iterations-et-les-erreurs","title":"Les it\u00e9rations et les erreurs","text":"<p>Dans le cas d'un algorithme de calcul num\u00e9rique, on s'int\u00e9resse \u00e0 la notion d'erreur afin de d\u00e9terminer le niveau de pr\u00e9cision atteint. Par exemple, voici quelques valeurs de l'approximation de \\(\\pi\\) avec leur valeur d'erreur.</p> <p> k Approximation de \\(\\pi\\) Erreur (arrondie \u00e0 6 chiffres) Nombre de chiffres pr\u00e9cis 0 4.000000 -0.588407 0 1 2.666666 0.474927 0 10 3.232316 -0.090723 1 100 3.151493 -0.009900 2 1 000 3.142592 -0.000999 3 10 000 3.141693 -0.000100 3 100 000 3.141603 -0.000010 4 1 000 000 3.141594 -0.000001 5 <p></p> <p>L'erreur est calcul\u00e9e en soustrayant la valeur approxim\u00e9e \u00e0 la valeur r\u00e9elle (\\(valeur r\u00e9elle - valeur approxim\u00e9e\\)). On peut g\u00e9n\u00e9ralement travailler avec la valeur absolue de cette erreur comme c'est \u00e7a grandeur qui est int\u00e9ressante et non son signe. </p>"},{"location":"algo/methodes_numeriques/#efficacite-des-calculs","title":"Efficacit\u00e9 des calculs","text":"<p>Certains algorithmes sont plus efficace que d'autres pour parvenir au calcul. Par exemple l'algorithme d'h\u00e9ron pour la racine carr\u00e9 prend la forme de la suite suivante pour la racine de \\(a\\) :</p> \\[ x_{k+1} = \\frac{x_{k} + \\frac{a}{x_k}}{2} \\] <p>L'efficacit\u00e9 de l'algorithme d\u00e9pend du terme \\(x_0 &gt; 0\\) choisi. Plus il est pr\u00e8s de \\(a\\), plus efficace sera l'algorithme.</p> <p> <p>Approximation de \\(\\sqrt{101}\\)</p> k Approximation avec \\(x_0 = 1\\) Erreur (arrondie \u00e0 4 chiffres) Approximation avec \\(x_0 = 10\\) Erreur (arrondie \u00e0 4 chiffres) 1 51 40,9501 10,05 0,0001 2 26,4901961 16,4403 10,0499 7,6966E-10 3 15,1514637 5,1016 10,0499 0 4 10,9087432 0,8589 10,0499 0 5 10,0836858 0,0338 10,0499 0 6 10,0499323 5,6682E-05 10,0499 0 7 10,0498756 1,5985E-10 10,0499 0 <p></p>"},{"location":"algo/methodes_numeriques/#les-erreurs-de-la-machine-et-les-limites-des-ordinateurs","title":"Les erreurs de la machine et les limites des ordinateurs","text":"<p>Les ordianteurs peuvent calculer un nombre maximal de d\u00e9cimales, ce qui cause une limitation dans la pr\u00e9cision des calculs et l'accumulation d'erreurs arithm\u00e9tiques. </p> <p>Donc le 0 qui appara\u00eet dans l'exemple sur les racines n'est pas un r\u00e9el 0, car il y a une infinit\u00e9 de d\u00e9cimale au d\u00e9veloppement num\u00e9rique de la racine de 101. C'est simplement que le programme utiliser ne consid\u00e8re pas assez de d\u00e9cimales pour remarquer une erreur num\u00e9rique.</p>"},{"location":"algo/methodes_numeriques/#les-pas-de-calcul","title":"Les pas de calcul","text":"<p>Certains algorithmes num\u00e9riques calculent la valeur d'une fonction sur un intervalle donn\u00e9. Dans ces cas, on n'\u00e9tudie pas le nombre d'it\u00e9rations, mais plut\u00f4t une valeur appel\u00e9 \u00ab\u00a0pas\u00a0\u00bb qui permet de subdiviser l'intervalle en plus petite zones. Plus le pas est petit, plus le calcul est pr\u00e9cis, mais plus il faut d'it\u00e9rations. Un exemple d'utilisation du pas est dans l'exercice 3 de la r\u00e9vision avec le MRUA.</p> <p>Un exemple d'utilisation du pas est dans le calcul d'int\u00e9grales num\u00e9riques, comme avec la m\u00e9thodes des trap\u00e8zes. Soit une fonction \\(f(x)\\) et un intervalle \\([a, b]\\) sur lequel \\(f\\) est continue, on cherche \u00e0 calculer :</p> \\[ \\int_{a}^{b}f(x)dx \\] <p>Par exemple, cherchons l'int\u00e9grale de \\(f(x) = x^3\\) pour l'intervalle [2, 4] en connaissance f(0) = 0. L'id\u00e9e est de recouvrir l'intervalle \u00e0 int\u00e9grer de trap\u00e8zes pour approximer l'int\u00e9grale.</p> Approximation avec 3 et 12 trap\u00e8zes <p>Donc l'algorithme num\u00e9rique consiste simplement \u00e0 additionner la valeur de l'aire de chaque trap\u00e8ze. On note \\(h\\) le pas de l'algorithme. L'aire du trap\u00e8ze est alors donn\u00e9e par :</p> \\[ A = \\frac{h(f(x) + f(x+h))}{2} = \\frac{h(x^3 + (x+h)^3)}{2} \\] <p> Nombre de trap\u00e8ze Valeur de \\(h\\) Valeur approxim\u00e9e Erreur 1 2 72 12 3 0.66667 61.33333 1.33333 12 0.16667 60.08333 0.08333 20 0.1 60.03 0.03 100 0.01 60.0012 0.0012 <p></p> Impl\u00e9mentation de la m\u00e9thode des trap\u00e8zes<pre><code>def f(x):\n    return x**3\n\ndef methode_trapeze(nb_trapezes, a, b):\n    h = (b-a) / nb_trapezes\n    integrale = 0\n\n    for i in range(nb_trapezes):\n        x_i = a + i * h\n        x_i_plus_1 = x_i + h\n        integrale += 0.5 * h * (f(x_i) + f(x_i_plus_1))\n\n    return integrale \n\n# Pour l'affichage\nprint(methode_trapeze(12, 2, 4))\n</code></pre>"},{"location":"algo/methodes_numeriques/#exercice","title":"Exercice","text":"<ol> <li>Faites le programme qui permet de calculer la valeur de \\(pi\\) avec la racine carr\u00e9e d'un nombre avec la formule d'H\u00e9ron.</li> <li>Calculez la racine de 6247 en utilisant 50 comme valeur initiale.</li> <li>Pour les it\u00e9rations entre 1 et 5, calculez l'erreur de la m\u00e9thode avec 4 d\u00e9cimales de pr\u00e9cision.</li> <li>Le ratio entre deux termes de la suite de Fibonacci approxime le nombre d'or \\(\\phi = \\frac{1+\\sqrt{5}}{2} \\approx 1.618034\\). \u00c0 l'aide de l'exercice 7 de la premi\u00e8re s\u00e9rie d'exercice, d\u00e9terminez combien de termes sont n\u00e9cessaires pour obtenir une approximation exacte \u00e0 4 chiffres de la valeur de \\(\\phi\\).</li> </ol>"},{"location":"programmer/revision/","title":"R\u00e9vision python","text":"<p> Contenus de la page</p> <p>R\u00e9viser les concepts de programmation en python</p> <p> Temps requis</p> <p>120 minutes</p> <p>Cette page contient des exercices de r\u00e9vision sur le langage de programmation Python, ainsi qu'une \u00e9valuation diagnostique \u00e0 remettre. Les exercices marqu\u00e9s comme [ED] sont \u00e0 remettre sur Teams dans le cadre de l'\u00e9valuation diagnostique. Le but de cette \u00e9valuation est de d\u00e9terminer le niveau de r\u00e9vision n\u00e9cessaire de programmation.</p> <p>Pour r\u00e9f\u00e9rence : notes de cours de programmation en science</p> <p>Bases de la programmation</p> <ol> <li>R\u00e9alisez les op\u00e9rations math\u00e9matiques suivantes :     a. Calculez l'aire d'un rectangle de hauteur 4 et largeur 5     b. Calculez l'aire d'un cercle de rayon 2.5     c. Calculez la longueur d'un c\u00f4t\u00e9 d'un carr\u00e9 d'aire 18</li> <li>R\u00e9alisez un calculateur d'angle int\u00e9rieur d'un triangle. On fournit deux angles au programme et il calcule le troisi\u00e8me.</li> <li>[ED] Adaptez le programme pour afficher une erreur si l'un des angles fourni est n\u00e9gatif ou l'angle calcul\u00e9 est n\u00e9gatif.</li> <li>R\u00e9alisez une fonction qui v\u00e9rifie si un nombre est premier. Vous pouvez faire ce test en testant tous les nombres jusqu'\u00e0 la racine du nombre. </li> <li>[ED] Adaptez le programme pour afficher tous les nombres premiers entre 2 et 100 inclusivement.</li> <li>R\u00e9alisez une fonction qui calcule la suite de Fibonacci jusqu'\u00e0 un nombre donn\u00e9. Par exemple, si vous indiquez 20, le programme affiche 1, 1, 2, 3, 5, 8, 13</li> <li>[ED] Adaptez le programme pour afficher le ratio de la division de deux nombres successifs de la suite de Fibonacci avec une pr\u00e9cision de 4 nombres (arrondi). Avec l'exemple pr\u00e9c\u00e9dent cela donne, 1.0000, 2.0000, 1.5000, 1.6667, 1.6000, 1.6250, 1.6154</li> </ol> Documentation |   |  Signaler une erreur"},{"location":"programmer/revision_numpy_collection/","title":"R\u00e9vision Python - liste, numpy et matplotlib","text":"<p> Contenus de la page</p> <p>R\u00e9viser les concepts de programmation en python</p> <p> Temps requis</p> <p>120 minutes</p> <p>Cette page contient des exercices de r\u00e9vision sur le langage de programmation Python en particulier l'utilisation des conteneurs de donn\u00e9es et de la biblioth\u00e8que Numpy. Certains probl\u00e8mes font appel \u00e0 des notions de physique ou math\u00e9matiques que vous pourriez ne pas avoir vues, selon votre parcours scolaire. N'h\u00e9sitez pas \u00e0 demander de l'aide pour ces notions.</p> <p>Pour r\u00e9f\u00e9rence : notes de cours de programmation en science</p> <ol> <li>On souhaite tester empiriquement le paradoxe des anniversaires. Faites une simulation o\u00f9 l'on s\u00e9lectionne une date d'anniversaire (un nombre entre 0 et 364 inclus) al\u00e9atoire dans un groupe de 23 personnes. R\u00e9p\u00e9tez la simulation 50 fois et calculez quelle proportion des groupes poss\u00e8de au moins deux individus qui ont la m\u00eame date d'anniversaire.</li> <li> <p>Importez les fonctions de l'exercice 1 dans un nouveau fichier revoir cette section. \u00c0 partir de cela, calculez, avec 100 r\u00e9p\u00e9titions de l'ex\u00e9cution :</p> <ol> <li>La plus petite proportion observ\u00e9e et le num\u00e9ro de la simulation associ\u00e9e</li> <li>La plus grande proportion observ\u00e9e et le num\u00e9ro de la simulation associ\u00e9e</li> <li>La moyenne et l'\u00e9cart-type</li> <li>L'intervalle de confiance \u00e0 5% (\\(z_{0.975}=1.96\\))</li> <li>Tous les r\u00e9sultats en ordre croissant</li> </ol> <p>Intervalle de confiance</p> <p>L'intervalle de confiance pour une moyenne est donn\u00e9 par </p> \\[ \\left[\\bar{x} - z_{0.975}\\frac{\\sigma}{\\sqrt{n}}; \\bar{x} + z_{0.975}\\frac{\\sigma}{\\sqrt{n}} \\right] \\] </li> <li> <p>On souhaite mesurer des positions d'un objet en chute libre (initialement au repos) pendant un certain intervalle de temps. Les mesures se prennent \u00e0 intervalle r\u00e9gulier de 0.1 seconde. On lance l'objet d'une masse de 3kg d'une hauteur de 50m. Vous devez mesurer jusqu'\u00e0 ce que l'objet atteigne le sol (hauteur de 0). Vous devez ensuite lire \u00e0 la console un choix de temps \u00e0 afficher et afficher la position de l'objet \u00e0 ce moment.</p> </li> <li>Tracez le graphique de la hauteur de l'objet en fonction du temps \u00e9coul\u00e9. Faites-le pour un intervalle de temps entre 0 et 4 secondes par intervalle de 0.1 seconde. Faites g\u00e9n\u00e9rer un graphique de type nuage de points et un graphique avec la courbe. En extra, g\u00e9rez le fait que le sol est \u00e0 0m et que l'objet ne peut descendre sous cette limite.</li> <li> <p>\u00c9valuez les expressions suivantes :</p> <ol> <li>\\(log(5)\\)</li> <li>\\(log_4(91)\\)</li> <li>\\(ln(7)\\)</li> <li>\\(e^8\\)</li> <li>\\(|-6|\\)</li> <li>\\(\\sqrt[3]475\\) </li> <li>\\(sin(\\frac{\\pi}{4})\\)</li> <li>\\(sec(\\frac{\\pi}{2})\\)</li> <li>\\(arctan(0.1)\\)</li> </ol> </li> </ol> Documentation |   |  Signaler une erreur"}]}